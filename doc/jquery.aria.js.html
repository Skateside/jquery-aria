<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>jquery.aria.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Externals</h3><ul><li><a href="external-jQuery.html">jQuery</a><ul class='methods'><li data-type='method'><a href="external-jQuery.html#.normaliseAria">normaliseAria</a></li><li data-type='method'><a href="external-jQuery.html#addRole">addRole</a></li><li data-type='method'><a href="external-jQuery.html#aria">aria</a></li><li data-type='method'><a href="external-jQuery.html#ariaFocusable">ariaFocusable</a></li><li data-type='method'><a href="external-jQuery.html#ariaRef">ariaRef</a></li><li data-type='method'><a href="external-jQuery.html#ariaState">ariaState</a></li><li data-type='method'><a href="external-jQuery.html#ariaVisible">ariaVisible</a></li><li data-type='method'><a href="external-jQuery.html#identify">identify</a></li><li data-type='method'><a href="external-jQuery.html#removeAria">removeAria</a></li><li data-type='method'><a href="external-jQuery.html#removeRole">removeRole</a></li><li data-type='method'><a href="external-jQuery.html#role">role</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">jquery.aria.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*! jquery-aria - v0.4.0a - 2017-02-27 */
(function ($) {
    "use strict";

/**
 * @file
 * This is a jQuery plugin that adds methods for manipulating WAI-ARIA
 * attributes. Unlike other plugins that do similar things, this plugin has been
 * designed to match jQuery's style making it much easier to pick up. The plugin
 * includes:
 * &lt;br>&lt;br>
 * &lt;strong>Getting and Setting WAI-ARIA Attributes&lt;/strong>
 * &lt;br>[jQuery#aria]{@link external:jQuery#aria} for getting and setting
 * WAI-ARIA attributes.
 * &lt;br>[jQuery#ariaRef]{@link external:jQuery#ariaRef} for getting and setting
 * references to other elements.
 * &lt;br>[jQuery#ariaState]{@link external:jQuery#ariaState} for getting and
 * setting states.
 * &lt;br>&lt;br>
 * &lt;strong>Removing WAI-ARIA Attributes&lt;/strong>
 * &lt;br>[jQuery#removeAria]{@link external:jQuery#removeAria} for removing
 * WAI-ARIA attributes (aliased as
 * [jQuery#removeAriaRef]{@link external:jQuery#removeAriaRef} and
 * [jQuery#removeAriaState]{@link external:jQuery#removeAriaState}).
 * &lt;br>&lt;br>
 * &lt;strong>Manipulating Landmarks&lt;/strong>
 * &lt;br>[jQuery#role]{@link external:jQuery#role},
 * [jQuery#addRole]{@link external:jQuery#addRole} and
 * [jQuery#removeRole]{@link external:jQuery#removeRole} handling WAI-ARIA
 * landmarks.
 * &lt;br>&lt;br>
 * &lt;strong>Helper Functions for Common Functionality&lt;/strong>
 * &lt;br>[jQuery#identify]{@link external:jQuery#identify} for generating element
 * IDs as necessary.
 * &lt;br>[jQuery#ariaVisible]{@link external:jQuery#ariaVisible} and
 * [jQuery#ariaFocusable]{@link external:jQuery#ariaFocusable} for toggling
 * common features.
 * &lt;br>[jQuery.normaliseAria]{@link external:jQuery.normaliseAria} for
 * simplifying the WAI-ARIA attributes (aliased as
 * [jQuery.normalizeAria]{@link external:jQuery.normalizeAria}).
 * &lt;br>&lt;br>
 * The files can be downloaded on
 * [GitHub]{@link https://github.com/Skateside/jquery-aria}.
 *
 * @author James "Skateside" Long &lt;sk85ide@hotmail.com>
 * @version 0.4.0a
 * @license MIT
 */

/**
 * @external jQuery
 * @see [jQuery]{@link http://jquery.com}
 */

/**
 * The [jQuery#aria]{@link external:jQuery#aria},
 * [jQuery#ariaRef]{@link external:jQuery#ariaRef} and
 * [jQuery#ariaState]{@link external:jQuery#ariaState} methods all take
 * functions to set their value. The functions all have the same signature,
 * described here. It is important to remember that the value this function
 * returns will be treated as if it had originally been passed to the
 * function. See
 * [jQuery#attr]{@link http://api.jquery.com/attr/#attr-attributeName-function}
 * for more information and examples.
 *
 * @callback Attribute_Callback
 * @this   HTMLElement
 *         The element being referenced.
 * @param  {Number} index
 *         The index of the current element from within the overall jQuery
 *         collection.
 * @param  {String|undefined} attr
 *         Current attribute value (undefined if the element does not
 *         currently have the attribute assigned).
 * @return {String}
 *         The value that should be passed to the function.
 *
 * @example
 * $("#one").aria("label", function (i, attr) {
 *     return "Test";
 * });
 * // is the same as
 * $("#one").aria("label", "Test");
 *
 * @example &lt;caption>Elements without the attribute pass undefined&lt;/caption>
 * // Markup is
 * // &lt;div id="one">&lt;/div>
 *
 * $("#one").aria("label", function (i, attr) {
 *     return Object.prototype.toString.call(attr);
 * });
 *
 * // Now markup is
 * // &lt;div id="one" aria-label="[object Undefined]">&lt;/div>
 */

/**
 * A boolean or the string "mixed" (always in lower case). This type will
 * be undefined when trying to read a state that has not been set on the
 * element.
 *
 * @typedef {Boolean|String|undefined} ARIA_state
 *
 * @example
 * // Markup is
 * // &lt;div id="one" aria-checked="true">&lt;/div>
 * // &lt;div id="two" aria-checked="false">&lt;/div>
 * // &lt;div id="three" aria-checked="mixed">&lt;/div>
 * // &lt;div id="four">&lt;/div>
 *
 * $("#one").ariaState("checked");   // -> true
 * $("#two").ariaState("checked");   // -> false
 * $("#three").ariaState("checked"); // -> "mixed"
 * $("#four").ariaState("checked");  // -> undefined
 */

/**
 * Any parameter that can be passed to
 * [jQuery's $ function]{@link http://api.jquery.com/jQuery/}. Be aware that
 * if the object (or Array or NodeList) contains multiple elements, only the
 * first will be used when getting information.
 *
 * @typedef {Array|Element|jQuery|NodeList|String} jQuery_param
 */

/**
 * Helper function for identifying the given &lt;code>reference&lt;/code>. The ID of
 * the first match is returned - see
 * [jQuery#identify]{@link external:jQuery#identify} for full details.
 *
 * @global
 * @private
 * @param   {jQuery_param} reference
 *          Element to identify.
 * @return  {String}
 *          ID of the element.
 */
var identify = function (reference) {
    return $(reference).identify();
};

/**
 * An identity function that simply returns whatever it is given without
 * modifying it. This can be useful for cases when a modification function is
 * needed but optional.
 *
 * @global
 * @private
 * @param  {?} x
 *         Object to return.
 * @return {?}
 *         Original object.
 *
 * @example
 * identity("a");           // -> "a"
 * identity("a", "b");      // -> "a", only first argument is returned.
 * identity.call("b", "a"); // -> "a", context has no effect.
 */
var identity = function (x) {
    return x;
};

/**
 * Interprets the given object as a string. If the object is &lt;code>null&lt;/code>
 * or &lt;code>undefined&lt;/code>, an empty string is returned.
 *
 * @global
 * @private
 * @param  {?} string
 *         Object to interpret.
 * @return {String}
 *         Interpreted string.
 *
 * @example
 * interpretString("1");       // -> "1"
 * interpretString(1);         // -> "1"
 * interpretString([1, 2]);    // -> "1,2"
 * interpretString(null);      // -> ""
 * interpretString(undefined); // -> ""
 * interpretString();          // -> ""
 */
var interpretString = function (string) {

    return (string === null || string === undefined)
        ? ""
        : String(string);

};

/**
 * Returns &lt;code>true&lt;/code> if the given &lt;code>element&lt;/code> is an HTML
 * element.
 *
 * @global
 * @private
 * @param  {?} element
 *         Object to test.
 * @return {Boolean}
 *         true if &lt;code>element&lt;/code> is an HTMLElement.
 *
 * @example
 * isElement(document.createElement("div")); // -> true
 * isElement(document.body); // -> true
 * isElement(document.createTextNode("")); // -> false
 * isElement($("body")); // -> false
 * isElement($("body")[0]); // -> true
 */
var isElement = function (element) {
    return element instanceof HTMLElement;
};

/**
 * Normalises a WAI-ARIA attribute name so that it's always lower case and
 * always stars with &lt;code>aria-&lt;/code>.
 * &lt;br>&lt;br>
 * This function is aliased as
 * [jQuery.normalizeAria]{@link external:jQuery.normalizeAria}.
 *
 * @alias    external:jQuery.normaliseAria
 * @memberof external:jQuery
 * @param    {String} name
 *           Attribute name to normalise.
 * @return   {String}
 *           Normalised attribute name.
 *
 * @example
 * $.normaliseAria("label");      // -> "aria-label"
 * $.normaliseAria("LABEL");      // -> "aria-label"
 * $.normaliseAria("aria-label"); // -> "aria-label"
 * $.normaliseAria();             // -> "aria-"
 *
 * // Alias:
 * $.normalizeAria("label"); // -> "aria-label"
 */
var normalise = function (name) {

    var lower = interpretString(name).toLowerCase();

    return startsWith.call(lower, "aria-")
        ? lower
        : "aria-" + lower;

};

/**
 * A fallback for older browsers that do not understand
 * [String#startsWith]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith}
 * without modifiying &lt;code>String.prototype&lt;/code> unnecessarily.
 *
 * @global
 * @private
 * @type   {Function}
 * @param  {String} text
 *         String to search for.
 * @param  {Number} [offset=0]
 *         Offset from which to start.
 * @return {Boolean}
 *         True if the string starts with &lt;code>text&lt;/code>, false otherwise.
 *
 * @example
 * startsWith.call("abcdef", "abc"); // -> true
 */
var startsWith = String.prototype.startsWith || function (text, offset) {
    return this.indexOf(text, offset) === 0;
};

/**
 * Converts the given string into an array of the words. The &lt;code>string&lt;/code>
 * argument is converted into a string before being split - see
 * {@link interpretString} for more information.
 *
 * @global
 * @private
 * @param  {String} string
 *         String (or other variable type) to break into words.
 * @return {Array.&lt;String>}
 *         Words from the string.
 *
 * @example
 * toWords("abc def");  // -> ["abc", "def"]
 * toWords("abc  def"); // -> ["abc", "def"]
 */
var toWords = function (string) {
    return interpretString(string).split(/\s+/);
};

var HANDLER_PROPERTY = "property";
var HANDLER_REFERENCE = "reference";
var HANDLER_STATE = "state";

/**
 * Handlers for properties, references and states. Each handler has at least a
 * &lt;code>get&lt;/code> and &lt;code>set&lt;/code> method to write and read the values.
 * &lt;code>has&lt;/code> methods check whether the property exists,
 * &lt;code>unset&lt;/code> removes the property.
 *
 * {@link handlers.reference} and {@link handlers.state} defer to
 * {@link handlers.property} (they don't inherit from {@link handlers.property}
 * but they may do in another implementation - any functionality they don't have
 * will be taken from {@link handlers.property}).
 *
 * @global
 * @namespace
 * @private
 */
var handlers = {};

/**
 * Handles WAI-ARIA properties without modifying the values any more than it
 * needs to. These methods also act as the fallback for other namespaces such as
 * {@link handlers.reference} and {@link handlers.state}.
 * &lt;br>{@link handlers.property.get} gets the value of the property.
 * &lt;br>{@link handlers.property.set} sets a property.
 * &lt;br>{@link handlers.property.has} checks to see if the property exists.
 * &lt;br>{@link handlers.property.unset} removes the property.
 *
 * @alias property
 * @memberof handlers
 * @namespace
 * @private
 */
handlers[HANDLER_PROPERTY] = {

    /**
     * Sets the property of an element. The &lt;code>value&lt;/code> is unchanged
     * (other than normal string coercion) and the &lt;code>name&lt;/code> is
     * normalised into a WAI-ARIA property (see
     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}).
     * &lt;br>&lt;br>
     * If &lt;code>element&lt;/code> is not an element (see {@link isElement}) then no
     * action will be taken.
     * &lt;br>&lt;br>
     * If &lt;code>value&lt;/code> is a function, it is treated like an
     * {@link Attribute_callback}. This is for consistency with
     * [jQuery#attr]{@link http://api.jquery.com/attr/}.
     * &lt;br>&lt;br>
     * A &lt;code>convert&lt;/code> function can also be passed. That function will
     * convert &lt;code>value&lt;/code> (if &lt;code>value&lt;/code> is a function,
     * &lt;code>convert&lt;/code> will convert the result) before assigning it. If
     * &lt;code>convert&lt;/code> is ommitted or not a function then {@link identity}
     * is used so &lt;code>value&lt;/code> will not be changed.
     *
     * @private
     * @param {Element}  element
     *        Element to have a property set.
     * @param {String}   name
     *        WAI-ARIA property to set.
     * @param {?}        value
     *        Value of the property.
     * @param {Number}   [index]
     *        Optional index of &lt;code>element&lt;/code> within the jQuery object.
     *        This is needed to keep consistency with the
     *        [jQuery#attr]{@link http://api.jquery.com/attr/} function and
     *        should be derived rather than manually passed.
     * @param {Function} [convert=identity]
     *        Optional conversion process. If ommitted, no conversion occurs.
     *
     * @example &lt;caption>Setting a property&lt;/caption>
     * // Markup is:
     * // &lt;div id="one">&lt;/div>
     *
     * var element = document.getElementById("one");
     * handlers.property.set(element, "label", "test");
     *
     * // Now markup is:
     * // &lt;div id="one" aria-label="test">&lt;/div>
     *
     * @example &lt;caption>Setting a property using a function&lt;/caption>
     * // Markup is:
     * // &lt;div id="one" aria-label="test">&lt;/div>
     *
     * var element = document.getElementById("one");
     * handlers.property.set(element, "label", function (i, attr) {
     *     return this.id + "__" + i + "__" + attr;
     * }, 0);
     *
     * // Now markup is:
     * // &lt;div id="one" aria-label="one__0__test">&lt;/div>
     *
     * @example &lt;caption>Converting the result&lt;/caption>
     * // Markup is:
     * // &lt;div id="one" aria-label="test">&lt;/div>
     *
     * var element = document.getElementById("one");
     * handlers.property.set(element, "label", function (i, attr) {
     *     return this.id + "__" + i + "__" + attr;
     * }, 0, function (value) {
     *     return value.toUpperCase();
     * });
     *
     * // Now markup is:
     * // &lt;div id="one" aria-label="ONE__0__TEST">&lt;/div>
     */
    set: function (element, name, value, index, convert) {

        var normalised = normalise(name);

        if ($.isFunction(value)) {

            value = value.call(
                element,
                index,
                element.getAttribute(normalised)
            );

        }

        if (!$.isFunction(convert)) {
            convert = identity;
        }

        if (isElement(element) || value === undefined) {
            element.setAttribute(normalised, convert(value));
        }

    },

    /**
     * Checks to see if the given &lt;code>name&lt;/code> exists on the given
     * &lt;code>element&lt;/code>. The &lt;code>name&lt;/code> is always normalised (see
     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}) and if
     * &lt;code>element&lt;/code> is not an element (see {@link isElement}) then
     * &lt;code>false&lt;/code> will always be returned.
     *
     * @private
     * @param  {Element} element
     *         Element to test.
     * @param  {String}  name
     *         WAI-ARIA property to check.
     * @return {Boolean}
     *         Whether or not the element has the given property.
     *
     * @example
     * // Markup is:
     * // &lt;div id="one" aria-label="test">&lt;/div>
     *
     * var element = document.getElementById("one");
     * handlers.property.has(element, "label"); // -> true
     * handlers.property.has(element, "busy");  // -> false
     */
    has: function (element, name) {

        return isElement(element)
            ? element.hasAttribute(normalise(name))
            : false;

    },

    /**
     * Gets the value of the WAI-ARIA property from the given
     * &lt;code>element&lt;/code> and returns it unchanged. The &lt;code>name&lt;/code> is
     * normalised (see
     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). If
     * &lt;code>element&lt;/code> is not an element (see {@link isElement}) or
     * &lt;code>name&lt;/code> is not recognised (see
     * {@link handlers.property.has}) then &lt;code>undefined&lt;/code> is returned.
     *
     * @private
     * @param  {Element}          element
     *         Element to access.
     * @param  {String}           name
     *         WAI-ARIA property to access.
     * @return {String|undefined}
     *         WAI-ARIA attribute or undefined if the attribute isn't set.
     *
     * @example
     * // Markup is:
     * // &lt;div id="one" aria-label="test">&lt;/div>
     *
     * var element = document.getElementById("one");
     * handlers.property.get(element, "label"); // -> "test"
     * handlers.property.get(element, "busy"); // -> undefined
     */
    get: function (element, name) {

        return handlers[HANDLER_PROPERTY].has(element, name)
            ? element.getAttribute(normalise(name))
            : undefined;

    },

    /**
     * Removes a WAI-ARIA attribute from the given &lt;code>element&lt;/code>. The
     * &lt;code>name&lt;/code> if normalised (see
     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}) and if
     * &lt;code>element&lt;/code> is not an element (see {@link isElement}) then no
     * action is taken.
     *
     * @private
     * @param {Element} element
     *        Element to modify.
     * @param {String}  name
     *        WAI-ARIA attribute to remove.
     *
     * @example
     * // Markup is:
     * // &lt;div id="one" aria-label="test">&lt;/div>
     *
     * var element = document.getElementById("one");
     * handlers.property.unset(element, "label");
     *
     * // Now markup is:
     * // &lt;div id="one">&lt;/div>
     */
    unset: function (element, name) {

        if (isElement(element)) {
            element.removeAttribute(normalise(name));
        }

    }

};

/**
 * Handles modifying WAI-ARIA references. Unlike {@link handlers.property}, this
 * will create references to elements and return them. The only defined methods
 * are:
 * &lt;br>{@link handlers.reference.set} sets a reference.
 * &lt;br>{@link handlers.reference.get} gets a reference.
 *
 * @alias reference
 * @memberof handlers
 * @namespace
 * @private
 */
handlers[HANDLER_REFERENCE] = {

    /**
     * Adds the WAI-ARIA reference to &lt;code>element&lt;/code>. This differs from
     * {@link handlers.property.set} in that &lt;code>reference&lt;/code> is passed
     * through [jQuery's $ function]{@link http://api.jquery.com/jquery/} and
     * identified (see [jQuery#identify]{@link external:jQuery#identify}) with
     * the ID of the first match being used. There is also no
     * &lt;code>convert&lt;/code> parameter.
     * &lt;br>&lt;br>
     * The &lt;code>name&lt;/code> is still normalised (see
     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). If
     * &lt;code>element&lt;/code> is not an element (see {@link isElement}) then no
     * action is taken.
     *
     * @private
     * @param {Element}      element
     *        Element to modify.
     * @param {String}       name
     *        WAI-ARIA attribute to set.
     * @param {jQuery_param} reference
     *        Element to reference.
     * @param {Number}       index
     *        Index of &lt;code>element&lt;/code> within the collection.
     *
     * @example
     * // Markup is:
     * // &lt;div class="one">&lt;/div>
     * // &lt;div class="two">&lt;/div>
     *
     * var element = document.querySelector(".one");
     * handlers.reference.set(element, "labelledby", ".two");
     *
     * // Now markup is:
     * // &lt;div class="one" aria=labelledby="anonymous0">&lt;/div>
     * // &lt;div class="two" id="anonymous0">&lt;/div>
     */
    set: function (element, name, reference, index) {

        handlers[HANDLER_PROPERTY].set(
            element,
            name,
            reference,
            index,
            identify
        );

    },

    /**
     * Gets the reference from the given &lt;code>element&lt;/code> and returns it as
     * a &lt;code>jQuery&lt;/code> object. This differs from
     * {@link handlers.property.get} in that the match is assumed to be an ID
     * and a DOM lookup is done based upon that. The &lt;code>name&lt;/code> is still
     * normalised (see
     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). If the
     * WAI-ARIA attribute is not found (see {@link handlers.property.has} then
     * &lt;code>undefined&lt;/code> is returned.
     *
     * @private
     * @param  {Element}          element
     *         Element to check.
     * @param  {String}           name
     *         WAI-ARIA reference.
     * @return {jQuery|undefined}
     *         jQuery object representing the reference or undefined if the
     *         attribute isn't set.
     *
     * @example
     * // Markup is:
     * // &lt;div id="one" aria=labelledby="two">&lt;/div>
     * // &lt;div id="two">&lt;/div>
     *
     * var element = document.getElementById("one");
     * handlers.reference.get(element, "labelledby");
     * // -> $(&lt;div id="two">)
     * handlers.reference.get(element, "controls");
     * // -> undefined
     */
    get: function (element, name) {

        var handler = handlers[HANDLER_PROPERTY];

        return handler.has(element, name)
            ? $("#" + handler.get(element, name))
            : undefined;

    }

};

var REGEXP_BOOLEAN = /^(?:true|false)$/;
var VALUE_MIXED = "mixed";

/**
 * Handles WAI-ARIA states. This differs from {@link handlers.property} in that
 * values are coerced into booleans before being set and a boolean (or the
 * string "mixed") will be returned.
 * &lt;br>{@link handlers.state.read} converts the value into a boolean.
 * &lt;br>{@link handlers.state.set} sets the state.
 * &lt;br>{@link handlers.state.get} gets the state.
 *
 * @alias state
 * @memberof handlers
 * @namespace
 * @private
 */
handlers[HANDLER_STATE] = {

    /**
     * Reads the raw value and converts it into a boolean or the string
     * &lt;code>"mixed"&lt;/code> (always lower case). If &lt;code>raw&lt;/code> cannot be
     * correctly converted, it is assumed to be &lt;code>true&lt;/code>.
     *
     * @private
     * @param  {?} raw
     *         Value to read.
     * @return {Boolean|String}
     *         Converted value.
     *
     * @example &lt;caption>Converting values&lt;/caption>
     * handlers.state.read(true);    // -> true
     * handlers.state.read("false"); // -> false
     * handlers.state.read("1");     // -> true
     * handlers.state.read(0);       // -> false
     * handlers.state.read("mixed"); // -> "mixed"
     *
     * @example &lt;caption>Unrecognised values default to true&lt;/caption>
     * handlers.state.read("2");      // -> true
     * handlers.state.read(-1);       // -> true
     * handlers.state.read([]);       // -> true
     * handlers.state.read("mixed."); // -> true
     */
    read: function readState(raw) {

        var state = true;

        switch (typeof raw) {

        case "boolean":

            state = raw;
            break;

        case "string":

            raw = raw.toLowerCase();

            if (raw === VALUE_MIXED) {
                state = raw;
            } else if (raw === "1" || raw === "0") {
                state = readState(+raw);
            } else if (REGEXP_BOOLEAN.test(raw)) {
                state = raw === "true";
            }

            break;

        case "number":

            if (raw === 0 || raw === 1) {
                state = !!raw;
            }

            break;

        }

        return state;

    },

    /**
     * Sets the WAI-ARIA state defined in &lt;code>name&lt;/code> on the given
     * &lt;code>element&lt;/code>. This differs from {@link handlers.property.set} in
     * that &lt;code>state&lt;/code> is converted into a boolean or
     * &lt;code>"mixed"&lt;/code> before being assigned (see
     * {@link handlers.state.read}) and there is no &lt;code>convert&lt;/code>
     * paramter. The &lt;code>name&lt;/code> is still normalised (see
     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}).
     *
     * @private
     * @param {Element} element
     *        Element to modify.
     * @param {String}  name
     *        WAI-ARIA attribute to set.
     * @param {?}       state
     *        State to set.
     * @param {Number}  index
     *        Index of &lt;code>element&lt;/code> within the collection.
     *
     * @example
     * // Markup is:
     * // &lt;div id="one">&lt;/div>
     * // &lt;div id="two">&lt;/div>
     *
     * var one = document.getElementById("one");
     * var two = document.getElementById("two");
     * handlers.state.set(one, "busy", true);
     * handlers.state.set(two, "checked", "mixed");
     *
     * // Now markup is:
     * // &lt;div id="one" aria-busy="true">&lt;/div>
     * // &lt;div id="two" aria-checked="mixed">&lt;/div>
     */
    set: function (element, name, state, index) {

        handlers[HANDLER_PROPERTY].set(
            element,
            name,
            state,
            index,
            handlers[HANDLER_STATE].read
        );

    },

    /**
     * Reads the WAI-ARIA state on &lt;code>element&lt;/code>. This differs from
     * {@link handlers.property.get} in that the result is converted into a
     * boolean or the strign `"mixed"` before being returned. The
     * &lt;code>name&lt;/code> is still normalised (see {@link jQuery.normaliseAria}).
     *
     * @private
     * @param  {Element}    element
     *         Element to access.
     * @param  {String}     name
     *         WAI-ARIA state to read.
     * @return {ARIA_state}
     *         State of the WAI-ARIA property.
     *
     * @example
     * // Markup is:
     * // &lt;div id="one" aria-busy="true" aria-checked="mixed">&lt;/div>
     *
     * var element = document.getElementById("one");
     * handlers.state.get(element, "busy");     // -> true
     * handlers.state.get(element, "checked");  // -> "mixed"
     * handlers.state.get(element, "disabled"); // -> undefined
     */
    get: function (element, name) {

        var handler = handlers[HANDLER_PROPERTY];
        var state;
        var value;

        if (handler.has(element, name)) {

            value = handler.get(element, name).toLowerCase();
            state = value === VALUE_MIXED
                ? value
                : (REGEXP_BOOLEAN.test(value) &amp;&amp; value === "true");

        }

        return state;

    }

};

/**
 * This function handles all the heavy lifting of getting or setting WAI-ARIA
 * attributes. It is designed to be all that's necessary for
 * [jQuery#aria]{@link external:jQuery#aria},
 * [jQuery#ariaRef]{@link external:jQuery#ariaRef} and
 * [jQuery#ariaState]{@link external:jQuery#ariaState}. This function will check
 * its arguments to determine whether it should be used as a getter or a setter
 * and passes the appropriate arguments to the {@link handlers} methods based on
 * &lt;code>type&lt;/code> (which will default to {@link handlers.property} if
 * ommitted or not recognised).
 * &lt;br>&lt;br>
 * The return value is based on the type of action being performed. If this
 * function is setting then a jQuery object of the matches is returned (which is
 * almost always &lt;code>jQelements&lt;/code>); if the function is a getter then the
 * results are returned for the first element in &lt;code>jQelements&lt;/code>.
 * &lt;br>&lt;br>
 * Although this description is not especially extensive, the code should be
 * very easy to follow and commented should there be any need to modify it. Once
 * the correct arguments are being passed to the appropriate {@link handlers}
 * method, they will take care of the rest.
 *
 * @global
 * @private
 * @param  {jQuery}            jQelements
 *         jQuery object to modify/access.
 * @param  {Object|String}     property
 *         Either WAI-ARIA names and values or the WAI-ARIA property name.
 * @param  {?}                 [value]
 *         Value to set.
 * @param  {String}            [type="property"]
 *         Optional attribute type.
 * @return {jQuery|ARIA_state}
 *         Either the jQuery object on which WAI-ARIA properties were set or the
 *         values of the WAI-ARIA properties.
 *
 * @example &lt;caption>Setting a single property&lt;/caption>
 * // Markup is
 * // &lt;div id="one">&lt;/div>
 *
 * var jQone = $("#one");
 * access(jQone, "controls", "two"); // -> jQuery(&lt;div id="one">)
 *
 * // Now markup is
 * // &lt;div id="one" aria-controls="two">
 *
 * @example &lt;caption>Setting multiple references&lt;/caption>
 * // Markup is
 * // &lt;div id="one">&lt;/div>
 * // &lt;div id="two">&lt;/div>
 *
 * var jQone = $("#one");
 * access(jQone, {
 *     controls: $("div").eq(1)
 * }, "reference"); // -> jQuery(&lt;div id="one">)
 *
 * // Now markup is
 * // &lt;div id="one" aria-controls="two">
 * // &lt;div id="two">&lt;/div>
 *
 * @example &lt;caption>Getting a state&lt;/caption>
 * // Markup is
 * // &lt;div id="one" aria-busy="true">&lt;/div>
 *
 * var jQone = $("#one");
 * access(jQone, "busy", undefined, "state"); // -> true
 */
function access(jQelements, property, value, type) {

    var tempProperty = property;
    var isPropertyObject = $.isPlainObject(property);
    var isGet = value === undefined &amp;&amp; !isPropertyObject;

    // Make sure the property value is in the expected format: an object for
    // setting and a string for getting.
    if (!isGet &amp;&amp; !isPropertyObject) {

        property = {};
        property[tempProperty] = value;

    }

    // If we don't have or don't recognise the type, default to "property".
    if (!type || !handlers[type]) {
        type = HANDLER_PROPERTY;
    }

    return isGet
        ? handlers[type].get(jQelements[0], property)
        : jQelements.each(function (index, element) {

            $.each(property, function (key, val) {
                handlers[type].set(element, key, val, index);
            });

        })

}

/**
 * Removes the named WAI-ARIA attribute from all elements in the current
 * collection. The &lt;code>name&lt;/code> is normalised (see
 * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). This function
 * is aliased as [jQuery#removeAriaRef]{@link external:jQuery#removeAriaRef} and
 * [jQuery#removeAriaState]{@link external:jQuery#removeAriaState}.
 *
 * @alias removeAria
 * @memberof external:jQuery
 * @instance
 * @param  {String} name
 *         WAI-ARIA attribute to remove.
 * @return {jQuery}
 *         jQuery attribute representing the elements modified.
 *
 * @example
 * // Markup is
 * // &lt;div id="one" aria-busy="true">&lt;/div>
 *
 * $("#one").removeAria("busy"); // -> jQuery(&lt;div id="one">)
 *
 * // Now markup is:
 * // &lt;div id="one">&lt;/div>
 */
function removeAttribute(name) {

    return this.each(function (ignore, element) {
        handlers[HANDLER_PROPERTY].unset(element, name);
    });

}

/**
 * Alias of [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}
 *
 * @alias external:jQuery.normalizeAria
 * @memberof external:jQuery
 * @type {Function}
 */
$.normalizeAria = normalise;
$.normaliseAria = normalise;

var IDENTIFY_PREFIX = "anonymous";
var count = 0;

/**
 * Identifies the first element in the collection by getting its ID. If the
 * element doesn't have an ID attribute, a unique on is generated and assigned
 * before being returned. If the collection does not have a first element then
 * &lt;code>undefined&lt;/code> is returned.
 * &lt;br>&lt;br>
 * IDs are a concatenation of "anonymous" and a hidden counter that is increased
 * each time. If the ID already exists on the page, that ID is skipped and not
 * assigned to a second element.
 *
 * @memberof external:jQuery
 * @instance
 * @alias    identify
 * @return   {String|undefined}
 *           The ID of the first element or undefined if there is no first
 *           element.
 *
 * @example &lt;caption>Identifying elements&lt;/caption>
 * // Markup is
 * // &lt;div class="one">&lt;/div>
 * // &lt;span class="one">&lt;/span>
 *
 * $(".one").identify(); // -> "anonymous0"
 *
 * // Now markup is:
 * // &lt;div class="one" id="anonymous0">&lt;/div>
 * // &lt;span class="one">&lt;/span>
 * // Running $(".one").identify(); again would not change the markup.
 *
 * @example &lt;caption>Existing IDs are not duplicated&lt;/caption>
 * // Markup is:
 * // &lt;div class="two" id="anonymous1">&lt;!-- manually set -->&lt;/div>
 * // &lt;div class="two">&lt;/div>
 * // &lt;div class="two">&lt;/div>
 *
 * $(".two").each(function () {
 *     $(this).identify();
 * });
 *
 * // Now markup is:
 * // &lt;div class="two" id="anonymous1">&lt;!-- manually set -->&lt;/div>
 * // &lt;div class="two" id="anonymous0">&lt;/div>
 * // &lt;div class="two" id="anonymous2">&lt;/div>
 */
$.fn.identify = function (index) {

    var element = this[0];
    var id = element &amp;&amp; element.id;

    if (element &amp;&amp; !id) {

        do {

            id = IDENTIFY_PREFIX + count;
            count += 1;

        } while (document.getElementById(id));

        element.id = id;

    }

    return id;

};

/**
 * Gets or sets WAI-ARIA properties. The properties will not be modified any
 * more than they need to be (unlike
 * [jQuery#ariaRef]{@link external:jQuery#ariaRef} or
 * [jQuery#ariaState]{@link external:jQuery#ariaState} which will interpret the
 * values).
 * &lt;br>&lt;br>
 * To set WAI-ARIA properties, pass either a
 * &lt;code>property&lt;/code>/&lt;code>value&lt;/code> pair of arguments or an object
 * containing those pairs. When this is done, the attributes are set on all
 * elements in the collection and the &lt;code>jQuery&lt;/code> object is returned to
 * allow for chaining. If &lt;code>value&lt;/code> is a function and returns
 * &lt;code>undefined&lt;/code> (or nothing) then no action is taken for that element.
 * This can be useful for selectively setting values only when certain criteria
 * are met.
 * &lt;br>&lt;br>
 * To get WAI-ARIA properties, only pass the &lt;code>property&lt;/code> that you want
 * to get. If there is no matching property, &lt;code>undefined&lt;/code> is returned.
 * All properties are normalised (see
 * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}).
 *
 * @memberof external:jQuery
 * @instance
 * @alias aria
 * @param  {Object|String} property
 *         Either the properties to set in key/value pairs or the name of the
 *         property to get/set.
 * @param  {Attribute_Callback|Boolean|Number|String} [value]
 *         The value of the property to set.
 * @return {jQuery|String|undefined}
 *         Either the jQuery object (after setting) or a string or undefined
 *         (after getting)
 *
 * @example &lt;caption>Setting WAI-ARIA attribute(s)&lt;/caption>
 * $("#element").aria("aria-label", "test");
 * // or
 * $("#element").aria("label", "test");
 * // or
 * $("#element").aria({
 *     "aria-label": "test"
 * });
 * // or
 * $("#element").aria({
 *     label: "test"
 * });
 * // All of these set aria-label="test" on all matching elements and return a
 * // jQuery object representing "#element"
 *
 * @example &lt;caption>Setting WAI-ARIA attribute(s) with a function&lt;/caption>
 * $("#element").aria("label", function (i, attr) {
 *     return this.id + "__" + i + "__" + attr;
 * });
 * // or
 * $("#element").aria({
 *     label: function (i, attr) {
 *         return this.id + "__" + i + "__" + attr;
 *     }
 * });
 * // Both of these set aria-label="element__0__undefined" on all matching
 * // elements and return a jQuery object representing "#element"
 *
 * @example &lt;caption>Getting a WAI-ARIA attribute&lt;/caption>
 * // Markup is:
 * // &lt;div id="element" aria-label="test">&lt;/div>
 * $("#element").aria("label");   // -> "test"
 * $("#element").aria("checked"); // -> undefined
 * // If "#element" matches multiple elements, the attributes from the first
 * // element are returned.
 */
$.fn.aria = function (property, value) {

    return access(
        this,
        property,
        value
    );

};

/**
 * Gets or sets a WAI-ARIA reference. This is functionally identical to
 * [jQuery#aria]{@link external:jQuery#aria} with the main difference being that
 * an element may be passed as the &lt;code>value&lt;/code> when setting and that a
 * jQuery object is returned when getting.
 * &lt;br>&lt;br>
 * Because WAI-ARIA references work with IDs, IDs are worked out using
 * [jQuery#identify]{@link external:jQuery#identify}. Be aware that any string
 * passed to [jQuery#ariaRef]{@link external:jQuery#ariaRef} will be treated
 * like a CSS selector and looked up with the results being used to set the
 * property. If you already have the ID and wish to set it without the lookup,
 * use [jQuery#aria]{@link external:jQuery#aria}.
 * &lt;br>&lt;br>
 * If &lt;code>value&lt;/code> is a function then the resulting value is identified.
 * This can be particularly useful for performing DOM traversal to find the
 * reference (see examples below). As with
 * [jQuery#aria]{@link external:jQuery#aria}, if the &lt;code>value&lt;/code> function
 * returns nothing or returns &lt;code>undefined&lt;/code> then no action is taken.
 * &lt;br>&lt;br>
 * When accessing the attribute using this function, a &lt;code>jQuery&lt;/code>
 * object representing the reference is returned. If there are multiple elements
 * in the collection, only the reference for the first element is returned. To
 * get the value of the attribute rather than the element, use
 * [jQuery#aria]{@link external:jQuery#aria}.
 *
 * @memberof external:jQuery
 * @instance
 * @alias ariaRef
 * @param  {Object|String} property
 *         Either the properties to set in key/value pairs or the name of the
 *         property to set.
 * @param  {Attribute_Callback|jQuery_param} [value]
 *         Reference to set.
 * @return {jQuery}
 *         jQuery object representing either the elements that were modified
 *         (when setting) or the referenced element(s) (when getting - may be an
 *         empty jQuery object).
 *
 * @example &lt;caption>Setting references&lt;/caption>
 * // Markup is:
 * // &lt;h1>Heading&lt;/h1>
 * // &lt;div class="one">
 * //     Lorem ipsum dolor sit amet ...
 * // &lt;/div>
 *
 * $(".one").ariaRef("labelledby", $("h1"));
 * // or
 * $(".one").ariaRef("labelledby", "h1");
 * // or
 * $(".one").ariaRef("labelledby", $("h1")[0]);
 * // or
 * $(".one").ariaRef({
 *     labelledby: $("h1") // or "h1" or $("h1")[0]
 * });
 * // Each of these return a jQuery object representing ".one"
 *
 * // Now markup is:
 * // &lt;h1 id="anonymous0">Heading&lt;/h1>
 * // &lt;div class="one" aria-labelledby="anonymous0">
 * //     Lorem ipsum dolor sit amet ...
 * // &lt;/div>
 *
 * @example &lt;caption>Setting references with a function&lt;/caption>
 * // Markup is:
 * // &lt;div class="js-collapse">
 * //     &lt;div class="js-collapse-content">
 * //         Lorem ipsum dolor sit amet ...
 * //     &lt;/div>
 * //     &lt;button class="js-collapse-toggle">
 * //         Toggle
 * //     &lt;/button>
 * // &lt;/div>
 *
 * $(".js-collapse-toggle").ariaRef("controls", function (i, attr) {
 *
 *     return $(this)
 *         .closest(".js-collapse")
 *         .find(".js-collapse-content");
 *
 * });
 *
 * // Now markup is:
 * // &lt;div class="js-collapse">
 * //     &lt;div class="js-collapse-content" id="anonymous0">
 * //         Lorem ipsum dolor sit amet ...
 * //     &lt;/div>
 * //     &lt;button class="js-collapse-toggle" aria-controls="anonymous0">
 * //         Toggle
 * //     &lt;/button>
 * // &lt;/div>
 *
 * @example &lt;caption>Getting a reference&lt;/caption>
 * // Markup is:
 * // &lt;h1 id="anonymous0">Heading&lt;/h1>
 * // &lt;div class="one" aria-labelledby="anonymous0">
 * //     Lorem ipsum dolor sit amet ...
 * // &lt;/div>
 *
 * $(".one").ariaRef("labelledby"); // -> $(&lt;h1>)
 * $(".one").ariaRef("controls");   // -> $()
 *
 * @example &lt;caption>Value is treated like a CSS selector&lt;/caption>
 * // Markup is:
 * // &lt;button id="button">&lt;/button>
 * // &lt;div id="section">&lt;/div>
 * // &lt;section>&lt;/section>
 *
 * $("#button").ariaRef("controls", "section");
 *
 * // Now markup is:
 * // &lt;button id="button" aria-controls="anonymous0">&lt;/button>
 * // &lt;div id="section">&lt;/div>
 * // &lt;section id="anonymous0">&lt;/section>
 */
$.fn.ariaRef = function (property, value) {

    return access(
        this,
        property,
        value,
        HANDLER_REFERENCE
    );

};

/**
 * Sets or gets the WAI-ARIA state of the collection.
 * &lt;br>&lt;br>
 * When setting the state, false, "false" (any case), 0 and "0" will be
 * considered false. All other values will be considered true except for "mixed"
 * (any case) which will set the state to "mixed". The differs from
 * [jQuery#aria]{@link external:jQuery#aria} which will simply set the
 * attribute(s) without converting the value.
 * &lt;br>&lt;br>
 * After setting the state(s), a jQuery object representing the affected
 * elements is returned. The state for the first matching element is returned
 * when getting.
 * &lt;br>&lt;br>
 * All attributes are normalised - see
 * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria} for full details.
 *
 * @memberof external:jQuery
 * @instance
 * @alias ariaState
 * @param  {Object|String} property
 *         Either a key/value combination properties to set or the name of the
 *         WAI-ARIA state to set.
 * @param  {Attribute_Callback|Boolean|Number|String} [value]
 *         Value of the attribute.
 * @return {ARIA_state|jQuery}
 *         Either the jQuery object representing the modified elements (setting)
 *         or the state of the first matching element.
 *
 * @example &lt;caption>Getting state&lt;/caption>
 * // Markup is:
 * // &lt;div id="one" aria-busy="true" aria-checked="mixed">&lt;/div>
 *
 * $("#one").ariaState("busy");    // -> true
 * $("#one").ariaState("checked"); // -> "mixed"
 * $("#one").ariaState("hidden");  // -> undefined
 *
 * @example &lt;caption>Setting state&lt;/caption>
 * // Each of these will set the state to false:
 * $("#one").ariaState("busy", "false");
 * $("#one").ariaState("busy", "FALSE");
 * $("#one").ariaState("busy", false);
 * $("#one").ariaState("busy", 0);
 * $("#one").ariaState("busy", "0");
 *
 * // Each of these will set the state to "mixed":
 * $("#one").ariaState("checked", "mixed");
 * $("#one").ariaState("checked", "MIXED");
 *
 * // Each of these will set the state to true
 * $("#one").ariaState("busy", "true");
 * $("#one").ariaState("busy", "TRUE");
 * $("#one").ariaState("busy", true);
 * $("#one").ariaState("busy", 1);
 * $("#one").ariaState("busy", "1");
 * // WARNING: these also set the state to true
 * $("#one").ariaState("busy", {});
 * $("#one").ariaState("busy", null);
 * $("#one").ariaState("busy", "nothing");
 * $("#one").ariaState("busy", "");
 * $("#one").ariaState("busy", -1);
 *
 * // Each example returns a jQuery object representing "#one" and an object
 * // can be passed as parameters as well:
 * $("#one").ariaState({
 *     busy: true
 * });
 *
 * @example &lt;caption>Setting state with a function&lt;/caption>
 * // Markup is:
 * // &lt;div class="checkbox">&lt;/div>
 * // &lt;input type="checkbox" checked>
 *
 * $(".checkbox").ariaState("checked", function (i, attr) {
 *
 *     return $(this)
 *         .next("input[type=\"checkbox\"]")
 *         .prop("checked");
 *
 * });
 *
 * // Now markup is:
 * // &lt;div class="checkbox" aria-checked="true">&lt;/div>
 * // &lt;input type="checkbox" checked>
 */
$.fn.ariaState = function (property, value) {

    return access(
        this,
        property,
        value,
        HANDLER_STATE
    );

};

$.fn.extend(/** @lends external:jQuery.prototype */{

    removeAria: removeAttribute,

    /**
     * Alias of [jQuery#removeAria]{@link external:jQuery#removeAria}.
     *
     * @type {Function}
     */
    removeAriaRef: removeAttribute,

    /**
     * Alias of [jQuery#removeAria]{@link external:jQuery#removeAria}.
     *
     * @type {Function}
     */
    removeAriaState: removeAttribute,

});

/**
 * Sets the role of all elements in the collection or gets the role of the first
 * element in the collection, depending on whether or not the &lt;code>role&lt;/code>
 * argument is provided. As [jQuery#role]{@link external:jQuery#role} is just a
 * wrapper for [jQuery#attr]{@link http://api.jquery.com/attr/}, the
 * &lt;code>role&lt;/code> parameter can actually be any value type that the official
 * documentation mentions.
 * &lt;br>&lt;br>
 * According to the WAI-ARIA specs, an element can have mutliple roles as a
 * space-separated list. This method will only set the role attribute to the
 * given string when setting. If you want to modify the roles, use
 * [jQuery#addRole]{@link external:jQuery#addRole} and
 * [jQuery#removeRole]{@link external:jQuery#removeRole}.
 *
 * @memberof external:jQuery
 * @instance
 * @alias role
 * @param  {Attribute_Callback|String} [role]
 *         Role to get or function to set the role.
 * @return {jQuery|String|undefined}
 *         Either the jQuery object representing the elements that were modified
 *         or the role value.
 *
 * @example
 * // Markup is:
 * // &lt;div id="one">&lt;/div>
 * // &lt;div id="two">&lt;/div>
 *
 * $("#one").role("presentation"); // -> jQuery(&lt;div id="one">)
 *
 * // Now markup is:
 * // &lt;div id="one" role="presentation">&lt;/div>
 * // &lt;div id="two">&lt;/div>
 *
 * $("#one").role(); // -> "presentation"
 * $("#two").role(); // -> undefined
 *
 * @example &lt;caption>Setting a role with a function&lt;/caption>
 * // Markup is:
 * // &lt;div id="one" role="button">&lt;/div>
 *
 * $("#one").role(function (index, current) {
 *     return current + " tooltip";
 * });
 *
 * // Now markup is:
 * // &lt;div id="one" role="button tooltip">&lt;/div>
 */
$.fn.role = function (role) {

    return role === undefined
        ? this.attr("role")
        : this.attr("role", role);

};

/**
 * Adds a role to a collection of elements. The role will not be added if it's
 * empty ("" or undefined), if the function response is empty or if the element
 * already has that role. In that way it's similar to
 * [jQuery#addClass]{@link https://api.jquery.com/addClass/}.
 *
 * @memberof external:jQuery
 * @instance
 * @alias addRole
 * @param  {Attribute_Callback|String} role
 *         Role(s) to add to the matching elements or function to generate the
 *         role(s) to add.
 * @return {jQuery}
 *         jQuery object representing the matching elements.
 *
 * @example &lt;caption>Adding a role&lt;/caption>
 * // Markup is:
 * // &lt;div class="one" role="presentation">&lt;/div>
 * // &lt;div class="one">&lt;/div>
 *
 * $(".one").addRole("alert"); // -> jQuery(&lt;div>, &lt;div>)
 *
 * // Now markup is:
 * // &lt;div class="one" role="presentation alert">&lt;/div>
 * // &lt;div class="one" role="alert">&lt;/div>
 *
 * @example &lt;caption>Adding a role with a function&lt;/caption>
 * // Markup is:
 * // &lt;div class="one" role="presentation">&lt;/div>
 *
 * $(".one").addRole(function (index, current) {
 *     return "alert combobox";
 * });
 *
 * // Now markup is:
 * // &lt;div class="one" role="presentation alert combobox">&lt;/div>
 */
$.fn.addRole = function (role) {

    var isFunction = $.isFunction(role);

    return this.role(function (index, current) {

        var value = isFunction
            ? role.call(this, index, current)
            : role;
        var roles = toWords(current);

        toWords(value).forEach(function (val) {

            if (
                val !== ""
                &amp;&amp; val !== undefined
                &amp;&amp; roles.indexOf(val) &lt; 0
            ) {
                roles.push(val);
            }

        });

        return roles.join(" ");

    });

};

/**
 * Removes roles from the collection of elements. If the method is called
 * without any arguments then the role attribute itself is removed. Be aware
 * that this is not the same as passing a function which returns undefined -
 * such an action will have no effect.
 *
 * @memberof external:jQuery
 * @instance
 * @alias removeRole
 * @param  {Attribute_Callback|String} [role]
 *         Role(s) to remove or a function to generate the role(s) to remove.
 * @return {jQuery}
 *         jQuery object representing the matched elements.
 *
 * @example &lt;caption>Removing a role&lt;/caption>
 * // Markup is:
 * // &lt;div class="one" role="presentation alert">&lt;/div>
 * // &lt;div class="one" role="alert">&lt;/div>
 *
 * $(".one").removeRole("alert"); // -> jQuery(&lt;div>, &lt;div>)
 *
 * // Now markup is:
 * // &lt;div class="one" role="presentation">&lt;/div>
 * // &lt;div class="one" role="">&lt;/div>
 *
 * @example &lt;caption>Completely removing a role&lt;/caption>
 * // Markup is:
 * // &lt;div class="one" role="presentation alert">&lt;/div>
 * // &lt;div class="one" role="alert">&lt;/div>
 *
 * $(".one").removeRole(); // -> jQuery(&lt;div>, &lt;div>)
 *
 * // Now markup is:
 * // &lt;div class="one">&lt;/div>
 * // &lt;div class="one">&lt;/div>
 *
 * @example &lt;caption>Removing a role with a function&lt;/caption>
 * // Markup is:
 * // &lt;div class="one" role="presentation alert combobox">&lt;/div>
 *
 * $(".one").removeRole(function (index, current) {
 *     return current
 *         .split(/\s+/)
 *         .filter(function (role) {
 *             return role.indexOf("a") > -1;
 *         })
 *         .join(" ");
 *     // "presentation alert"
 * });
 *
 * // Now markup is:
 * // &lt;div class="one" role="combobox">&lt;/div>
 */
$.fn.removeRole = function (role) {

    var isFunction = $.isFunction(role);

    return role === undefined
        ? this.removeAttr("role")
        : this.role(function (index, current) {

            var value = isFunction
                ? role.call(this, index, current)
                : role;
            var values = toWords(value);

            return toWords(current)
                .filter(function (aRole) {
                    return values.indexOf(aRole) &lt; 0;
                })
                .join(" ");

        });

};

/**
 * Sets the visibility of the matching elements on a WAI-ARIA level. Strings,
 * numbers and booleans are understood as &lt;code>state&lt;/code> - see
 * [jQuery#ariaState]{@link external:jQuery#ariaState} for full details as the
 * algorythm is the same.
 * &lt;br>&lt;br>
 * Note that according to the WAI-ARIA specs, declaring an element to be visible
 * should be done by removing the &lt;code>aria-hidden&lt;/code> attribute rather than
 * setting the value to &lt;code>false&lt;/code>.
 * &lt;br>&lt;br>
 * Be aware that this function will only modify the &lt;code>aria-hidden&lt;/code> of
 * the matching elements. It's possible that after running this function, the
 * element cannot be seen visually or is still hidden to WAI-ARIA devices.
 *
 * @memberof external:jQuery
 * @instance
 * @alias ariaVisible
 * @param  {Attribute_Callback|Boolean|Number|String} state
 *         State to set.
 * @return {jQuery}
 *         jQuery object representing the affected element(s).
 *
 * @example &lt;caption>Setting WAI-ARIA visibility&lt;/caption>
 * // Markup is
 * // &lt;div id="one" aria-hidden="true">&lt;/div>
 * // &lt;div id="two">&lt;/div>
 *
 * $("#one").ariaVisible(false); // -> jQuery(&lt;div id="one">)
 * $("#two").ariaVisible(true);  // -> jQuery(&lt;div id="two">)
 *
 * // Now markup is
 * // &lt;div id="one">&lt;/div>
 * // &lt;div id="two" aria-hidden="true">&lt;/div>
 *
 * @example &lt;caption>Limitations of the function&lt;/caption>
 * // Markup is
 * // &lt;div id="one" aria-hidden="true">
 * //     &lt;div id="two" aria-hidden="true" style="display:none">&lt;/div>
 * // &lt;/div>
 *
 * $("#two").ariaVisible(true); // -> jQuery(&lt;div id="two">)
 *
 * // Now markup is
 * // &lt;div id="one" aria-hidden="true">
 * //     &lt;div id="two" style="display:none">&lt;/div>
 * // &lt;/div>
 */
$.fn.ariaVisible = function (state) {

    var theState = handlers[HANDLER_STATE].read(state);

    return theState
        ? access(this, "hidden", theState)
        : this.removeAttr("hidden");

};

/**
 * Sets whether or not the matching elements are focusable. Strings, numbers and
 * booleans are understood as &lt;code>state&lt;/code> - see
 * [jQuery#ariaState]{@link external:jQuery#ariaState} for full details as the
 * algorythm is the same.
 * &lt;br>&lt;br>
 * Be aware this this function will only modify the matching elements, it will
 * not check any parents or modify any other elements that could affect the
 * focusability of the element.
 *
 * @memberof external:jQuery
 * @instance
 * @alias ariaFocusable
 * @param  {Attribute_Callback|Boolean|Number|String} state
 *         State to set.
 * @return {jQuery}
 *         jQuery object representing the affected element(s).
 *
 * @example &lt;caption>Setting focusability&lt;/caption>
 * // Markup is
 * // &lt;div id="one">&lt;/div>
 * // &lt;div id="two">&lt;/div>
 *
 * $("#one").ariaFocusable(false); // -> jQuery(&lt;div id="one">)
 * $("#two").ariaFocusable(true);  // -> jQuery(&lt;div id="two">)
 *
 * // Now markup is
 * // &lt;div id="one" tabindex="0">&lt;/div>
 * // &lt;div id="two" tabindex="-1">&lt;/div>
 *
 * @example &lt;caption>Limitations of the function&lt;/caption>
 * // Markup is
 * // &lt;div id="one" tabindex="-1">
 * //     &lt;div id="two" disabled>&lt;/div>
 * // &lt;/div>
 *
 * $("#two").ariaFocusable(true); // -> jQuery(&lt;div id="two">)
 *
 * // Now markup is
 * // &lt;div id="one" tabindex="-1">
 * //     &lt;div id="two" disabled tabindex="0">&lt;/div>
 * // &lt;/div>
 */
$.fn.ariaFocusable = function (state) {

    return access(
        this,
        "tabindex",
        handlers[HANDLER_STATE].read(state)
            ? 0
            : -1
    );

};

}(jQuery));</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Feb 27 2017 22:13:37 GMT+0000 (GMT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
