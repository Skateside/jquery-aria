{"version":3,"sources":["jquery.aria.js"],"names":["$","access","jQelements","property","value","type","tempProperty","isPropertyObject","isPlainObject","isGet","undefined","handlers","HANDLER_PROPERTY","get","each","index","element","key","val","set","removeAttribute","name","this","ignore","unset","IS_PROXY_AVAILABLE","window","Proxy","toString","indexOf","identify","reference","identity","x","interpretString","string","String","isElement","test","nodeName","nodeType","normalise","handler","resolver","hasOwn","Object","prototype","hasOwnProperty","slice","Array","memoised","mem","args","call","arguments","apply","join","response","cache","lower","toLowerCase","full","stem","length","map","ariaFix","JSON","stringify","toWords","split","filter","parse","normal","convert","prop","hook","ariaHooks","isFunction","getAttribute","setAttribute","has","hasAttribute","REGEXP_BOOLEAN","read","readState","raw","state","normalizeAria","normaliseAria","labeledby","target","hidden","count","fn","isAnElement","id","document","getElementById","aria","ariaRef","ariaState","extend","removeAria","removeAriaRef","removeAriaState","role","attr","addRole","current","roles","forEach","push","removeRole","removeAttr","values","aRole","ariaFocusable","jQuery"],"mappings":"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","file":"jquery.aria.min.js","sourcesContent":["/*! jquery-aria (https://github.com/Skateside/jquery-aria#readme) - v0.7.0a - MIT license - 2017-9-28 */\n(function ($) {\n    \"use strict\";\n\n// Source: \\src\\doc\\file.js\n/**\r\n * @file\r\n * This is a jQuery plugin that adds methods for manipulating WAI-ARIA\r\n * attributes. Unlike other plugins that do similar things, this plugin has been\r\n * designed to match jQuery's style making it much easier to pick up. The plugin\r\n * includes:\r\n * <br><br>\r\n * <strong>Getting and Setting WAI-ARIA Attributes</strong>\r\n * <br>[jQuery#aria]{@link external:jQuery#aria} for getting and setting\r\n * WAI-ARIA attributes.\r\n * <br>[jQuery#ariaRef]{@link external:jQuery#ariaRef} for getting and setting\r\n * references to other elements.\r\n * <br>[jQuery#ariaState]{@link external:jQuery#ariaState} for getting and\r\n * setting states.\r\n * <br><br>\r\n * <strong>Removing WAI-ARIA Attributes</strong>\r\n * <br>[jQuery#removeAria]{@link external:jQuery#removeAria} for removing\r\n * WAI-ARIA attributes (aliased as\r\n * [jQuery#removeAriaRef]{@link external:jQuery#removeAriaRef} and\r\n * [jQuery#removeAriaState]{@link external:jQuery#removeAriaState}).\r\n * <br><br>\r\n * <strong>Adjusting WAI-ARIA Attribute Manipulation</strong>\r\n * <br>[jQuery.ariaFix]{@link external:jQuery.ariaFix} will convert the names of\r\n * WAI-ARIA attributes.\r\n * <br>[jQuery.ariaHooks]{@link external:jQuery.ariaHooks} allow special\r\n * functionality to be defined for specific WAI-ARIA attributes.\r\n * <br><br>\r\n * <strong>Manipulating Landmarks</strong>\r\n * <br>[jQuery#role]{@link external:jQuery#role},\r\n * [jQuery#addRole]{@link external:jQuery#addRole} and\r\n * [jQuery#removeRole]{@link external:jQuery#removeRole} handling WAI-ARIA\r\n * landmarks.\r\n * <br><br>\r\n * <strong>Helper Functions for Common Functionality</strong>\r\n * <br>[jQuery#identify]{@link external:jQuery#identify} for generating element\r\n * IDs as necessary.\r\n * <br>[jQuery#ariaFocusable]{@link external:jQuery#ariaFocusable} for toggling\r\n * focusability.\r\n * <br>[jQuery.normaliseAria]{@link external:jQuery.normaliseAria} for\r\n * simplifying the WAI-ARIA attributes (aliased as\r\n * [jQuery.normalizeAria]{@link external:jQuery.normalizeAria}).\r\n * <br><br>\r\n * The files can be downloaded on\r\n * [GitHub]{@link https://github.com/Skateside/jquery-aria}.\r\n *\r\n * @author James \"Skateside\" Long <sk85ide@hotmail.com>\r\n * @version 0.7.0a\r\n * @license MIT\r\n */\r\n\r\n// Source: \\src\\doc\\external\\jQuery.js\n/**\r\n * @external jQuery\r\n * @see [jQuery]{@link http://jquery.com}\r\n */\r\n\r\n// Source: \\src\\doc\\callback\\Attribute_Callback.js\n/**\r\n * The [jQuery#aria]{@link external:jQuery#aria},\r\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef} and\r\n * [jQuery#ariaState]{@link external:jQuery#ariaState} methods all take\r\n * functions to set their value. The functions all have the same signature,\r\n * described here. It is important to remember that the value this function\r\n * returns will be treated as if it had originally been passed to the\r\n * function. See\r\n * [jQuery#attr]{@link http://api.jquery.com/attr/#attr-attributeName-function}\r\n * for more information and examples.\r\n *\r\n * @callback Attribute_Callback\r\n * @this     HTMLElement\r\n *           The element being referenced.\r\n * @param    {Number} index\r\n *           The index of the current element from within the overall jQuery\r\n *           collection.\r\n * @param    {String|undefined} attr\r\n *           Current attribute value (undefined if the element does not\r\n *           currently have the attribute assigned).\r\n * @return   {String}\r\n *           The value that should be passed to the function.\r\n *\r\n * @example\r\n * $(\"#one\").aria(\"label\", function (i, attr) {\r\n *     return \"Test\";\r\n * });\r\n * // is the same as\r\n * $(\"#one\").aria(\"label\", \"Test\");\r\n *\r\n * @example <caption>Elements without the attribute pass undefined</caption>\r\n * // Markup is\r\n * // <div id=\"one\"></div>\r\n *\r\n * $(\"#one\").aria(\"label\", function (i, attr) {\r\n *     return Object.prototype.toString.call(attr);\r\n * });\r\n *\r\n * // Now markup is\r\n * // <div id=\"one\" aria-label=\"[object Undefined]\"></div>\r\n */\r\n\r\n// Source: \\src\\doc\\typedef\\ARIA_state.js\n/**\r\n * A boolean or the string \"mixed\" (always in lower case). This type will\r\n * be undefined when trying to read a state that has not been set on the\r\n * element.\r\n *\r\n * @typedef {Boolean|String|undefined} ARIA_state\r\n *\r\n * @example\r\n * // Markup is\r\n * // <div id=\"one\" aria-checked=\"true\"></div>\r\n * // <div id=\"two\" aria-checked=\"false\"></div>\r\n * // <div id=\"three\" aria-checked=\"mixed\"></div>\r\n * // <div id=\"four\"></div>\r\n *\r\n * $(\"#one\").ariaState(\"checked\");   // -> true\r\n * $(\"#two\").ariaState(\"checked\");   // -> false\r\n * $(\"#three\").ariaState(\"checked\"); // -> \"mixed\"\r\n * $(\"#four\").ariaState(\"checked\");  // -> undefined\r\n */\r\n\r\n// Source: \\src\\doc\\typedef\\ARIA_hook.js\n/**\r\n * A hook for a WAI-ARIA attribute. Every property is optional so there is no\r\n * need to specify one to execute the default functionality.\r\n * <br><br>\r\n * Be aware that these hooks only affect the aria methods;\r\n * [jQuery#attr]{@link http://api.jquery.com/attr/} and\r\n * [jQuery#prop]{@link http://api.jquery.com/prop/} will not be affected by any\r\n * changes here. There are similar <code>jQuery.attrHooks</code> and\r\n * <code>jQuery.propHooks</code> (for set and get) that work in the same way if\r\n * you need to completely control attribute/property setting.\r\n *\r\n * @typedef  {Object}          ARIA_hook\r\n * @property {ARIA_hook_set}   [set]\r\n *           Handles setting the attribute.\r\n * @property {ARIA_hook_get}   [get]\r\n *           Handles getting the attribute.\r\n * @property {ARIA_hook_has}   [has]\r\n *           Handlers checking whether or not the attribute is assigned.\r\n * @property {ARIA_hook_unset} [unset]\r\n *           Handles removing the attribute.\r\n */\r\n\r\n/**\r\n * Handles the setting of a WAI-ARIA attribute. If the function returns a value,\r\n * that value is used to set the attribute; returning null, undefined, or not\r\n * returning anything will prevent the normal attribute setting process from\r\n * completing.\r\n * <br><br>\r\n * When setting an attribute, please do not use\r\n * [jQuery#aria]{@link external:jQuery#aria},\r\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef} or\r\n * [jQuery#ariaState]{@link external:jQuery#ariaState} as this can create an\r\n * infinite loop.\r\n *\r\n * @typedef {Function}    ARIA_hook_set\r\n * @param   {HTMLElement}           element\r\n *          Element whose attribute should be modified.\r\n * @param   {Boolean|Number|String} value\r\n *          Value of the attribute in the form given to the aria function.\r\n * @param   {String}                attribute\r\n *          Full attribute name, lower case and including \"aria-\" prefix.\r\n * @return  {?}\r\n *          Possible conversion of the value.\r\n *\r\n * @example <caption>Setting fictitious \"volume\" or \"soundsetup\" attributes</caption>\r\n * $.ariaHooks.volume = {\r\n *     // Let's assume that the value must be a positive integer and that any\r\n *     // other value should be ignored.\r\n *     set: function (element, value, attribute) {\r\n *         var posInt = Math.floor(Math.abs(value));\r\n *         return isNaN(posInt)\r\n *             ? undefined\r\n *             : posInt;\r\n *     }\r\n * };\r\n * $.ariaHooks.soundsetup = {\r\n *     // Let's assume that the value can only be something in a set list and\r\n *     // that everything else should be ignored.\r\n *     set: function (element, value, attribute) {\r\n *         var values = [\"mono\", \"stereo\", \"5.1\"];\r\n *         return values.indexOf(value) > -1\r\n *             ? value\r\n *             : undefined;\r\n *     }\r\n * };\r\n *\r\n * // Markup is:\r\n * // <div id=\"one\"></div>\r\n * // <div id=\"two\"></div>\r\n *\r\n * $(\"#one\").aria({\r\n *     volume: 5,\r\n *     soundsetup: \"mono\"\r\n * });\r\n * $(\"#two\").aria({\r\n *     volume: \"loud\",\r\n *     soundsetup: \"legendary\"\r\n * });\r\n *\r\n * // Now markup is:\r\n * // <div id=\"one\" aria-volume=\"5\" aria-soundsetup=\"mono\"></div>\r\n * // <div id=\"two\"></div>\r\n */\r\n\r\n/**\r\n * Handles the getting of a WAI-ARIA attribute. The function takes the element\r\n * and should return the value that the jQuery aria methods should return.\r\n * <br><br>\r\n * When getting an attribute, please do not use\r\n * [jQuery#aria]{@link external:jQuery#aria},\r\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef} or\r\n * [jQuery#ariaState]{@link external:jQuery#ariaState} as this can create an\r\n * infinite loop.\r\n *\r\n * @typedef {Function}    ARIA_hook_get\r\n * @param   {HTMLElement} element\r\n *          Element whose attribute value should be returned.\r\n * @param   {String}      attribute\r\n *          Full attribute name, lower case and including \"aria-\" prefix.\r\n * @return  {?Boolean|Number|String}\r\n *          Value of the attribute.\r\n *\r\n * @example <caption>Getting a fictitious \"volume\" attribute</caption>\r\n * $.ariaHooks.volume = {\r\n *     // Let's assume that the value will be a positive integer and if it\r\n *     // contains another value, or is missing, it defaults to 0.\r\n *     get: function (element, attribute) {\r\n *         var value = element.getAttribute(attribute);\r\n *         return (value === null || isNaN(value) || value < 0)\r\n *             ? 0\r\n *             : Math.floor(value);\r\n *     }\r\n * };\r\n *\r\n * // Markup is:\r\n * // <div id=\"one\" aria-volume=\"5\"></div>\r\n * // <div id=\"two\" aria-volume=\"loud\"></div>\r\n *\r\n * $(\"#one\").aria(\"volume\"); // -> 5\r\n * $(\"#two\").aria(\"volume\"); // -> 0\r\n */\r\n\r\n/**\r\n * Handles checking whether or not the WAI-ARIA attribute exists on the element\r\n * and it should return a boolean. Currently this functionality is not exposed\r\n * in an aria method, but the existence of a WAI-ARIA attribute will be checked\r\n * before getting occurs (and the {@link ARIA_hook_get} function executes).\r\n *\r\n * @typedef {Function}    ARIA_hook_has\r\n * @param   {HTMLElement} element\r\n *          Element whose attribute should be checked.\r\n * @param   {String}      attribute\r\n *          Full attribute name, lower case and including \"aria-\" prefix.\r\n * @return  {Boolean}\r\n *          Whether or not the attribute exists on the element (true if it\r\n *          does, false otherwise).\r\n *\r\n * @example <caption>Checking for a fictitious \"volume\" attribute</caption>\r\n * $.ariaHooks.volume = {\r\n *     get: function (element, attribute) {\r\n *         console.log(\"hi\");\r\n *         return element.getAttribute(attribute);\r\n *     },\r\n *     // Let's assume that the attribute has to contain a positive integer and\r\n *     // will be considered non-existent if it contains anything else.\r\n *     has: function (element, attribute) {\r\n *         var value = element.getAttribute(attribute);\r\n *         var intVal = parseInt(value, 10);\r\n *         return value !== null && intVal === +value && intVal <= 0;\r\n *     }\r\n * };\r\n *\r\n * // Markup is:\r\n * // <div id=\"one\" aria-volume=\"5\"></div>\r\n * // <div id=\"two\" aria-volume=\"loud\"></div>\r\n *\r\n * $(\"#one\").aria(\"volume\");\r\n * // Logs: \"hi\"\r\n * // -> \"5\"\r\n * $(\"#two\").aria(\"volume\"); // -> undefined\r\n */\r\n\r\n/**\r\n * Checks to see if the WAI-ARIA attribute should be removed. If the function\r\n * returns <code>true</code> (or a truthy value) then the attribute will be\r\n * removed, a falsy value will prevent the attribute being removed through the\r\n * aria methods (although there is nothing stopping it being removed in another\r\n * way or even through the function itself).\r\n * <br><br>\r\n * When removing an attribute, please do not use\r\n * [jQuery#removeAria]{@link external:jQuery#removeAria},\r\n * [jQuery#removeAriaRef]{@link external:jQuery#removeAriaRef} or\r\n * [jQuery#removeAriaState]{@link external:jQuery#removeAriaState} as this can\r\n * create an infinite loop.\r\n *\r\n * @typedef {Function}    ARIA_hook_unset\r\n * @param   {HTMLElement} element\r\n *          Element whose attribute should be removed.\r\n * @param   {String}      attribute\r\n *          Full attribute name, lower case and including \"aria-\" prefix.\r\n * @return  {Boolean}\r\n *          Whether or not the attribute should be removed.\r\n *\r\n * @example <caption>Removing a fictitious \"volume\" attribute</caption>\r\n * $.ariaHooks.volume = {\r\n *     // Let's assume that there is also a \"soundsetup\" attribute and that it\r\n *     // requires the \"volume\" attribute to exist, thus if \"volume\" is removed,\r\n *     // \"soundsetup\" should be removed as well.\r\n *     unset: function (element, attribute) {\r\n *         element.removeAttribute(\"aria-soundsetup\");\r\n *         return true;\r\n *     }\r\n * };\r\n *\r\n * // Markup is:\r\n * // <div id=\"one\" aria-volume=\"5\" aria-soundsetup=\"mono\"></div>\r\n *\r\n * $(\"#one\").removeAria(\"volume\");\r\n *\r\n * // Now markup is\r\n * // <div id=\"one\"></div>\r\n */\r\n\r\n// Source: \\src\\doc\\typedef\\jQuery_param.js\n/**\r\n * Any parameter that can be passed to\r\n * [jQuery's $ function]{@link http://api.jquery.com/jQuery/}. Be aware that\r\n * if the object (or Array or NodeList) contains multiple elements, only the\r\n * first will be used when getting information.\r\n *\r\n * @typedef {Array|Element|jQuery|NodeList|String} jQuery_param\r\n */\r\n\r\n// Source: \\src\\global\\variables.js\n\r\n\r\n// A simple check to see if there is a global Proxy function and it's native.\r\n// Although this isn't fool-proof, it's a fairly reliable way of checking\r\n// whether or not the browser supports Proxy.\r\nvar IS_PROXY_AVAILABLE = (\r\n    typeof window.Proxy === \"function\"\r\n    && window.Proxy.toString().indexOf(\"[native code]\") > -1\r\n);\r\n\r\n// Source: \\src\\global\\identify.js\n\r\n\r\n/**\r\n * Helper function for identifying the given <code>reference</code>. The ID of\r\n * the first match is returned - see\r\n * [jQuery#identify]{@link external:jQuery#identify} for full details.\r\n *\r\n * @global\r\n * @private\r\n * @param   {jQuery_param} reference\r\n *          Element to identify.\r\n * @return  {String}\r\n *          ID of the element.\r\n */\r\nvar identify = function (reference) {\r\n\r\n    return $(reference).identify();\r\n\r\n};\r\n\r\n// Source: \\src\\global\\identity.js\n/**\r\n * An identity function that simply returns whatever it is given without\r\n * modifying it. This can be useful for cases when a modification function is\r\n * needed but optional.\r\n *\r\n * @global\r\n * @private\r\n * @param   {?} x\r\n *          Object to return.\r\n * @return  {?}\r\n *          Original object.\r\n *\r\n * @example\r\n * identity(\"a\");           // -> \"a\"\r\n * identity(\"a\", \"b\");      // -> \"a\", only first argument is returned.\r\n * identity.call(\"b\", \"a\"); // -> \"a\", context has no effect.\r\n */\r\nvar identity = function (x) {\r\n\r\n    return x;\r\n\r\n};\r\n\r\n// Source: \\src\\global\\interpretString.js\n/**\r\n * Interprets the given object as a string. If the object is <code>null</code>\r\n * or <code>undefined</code>, an empty string is returned.\r\n *\r\n * @global\r\n * @private\r\n * @param   {?} string\r\n *          Object to interpret.\r\n * @return  {String}\r\n *          Interpreted string.\r\n *\r\n * @example\r\n * interpretString(\"1\");       // -> \"1\"\r\n * interpretString(1);         // -> \"1\"\r\n * interpretString([1, 2]);    // -> \"1,2\"\r\n * interpretString(null);      // -> \"\"\r\n * interpretString(undefined); // -> \"\"\r\n * interpretString();          // -> \"\"\r\n */\r\nvar interpretString = function (string) {\r\n\r\n    return (string === null || string === undefined)\r\n        ? \"\"\r\n        : String(string);\r\n\r\n};\r\n\r\n// Source: \\src\\global\\isElement.js\n/**\r\n * Returns <code>true</code> if the given <code>element</code> is an HTML\r\n * element.\r\n *\r\n * @global\r\n * @private\r\n * @param   {?} element\r\n *          Object to test.\r\n * @return  {Boolean}\r\n *          true if <code>element</code> is an HTMLElement.\r\n *\r\n * @example\r\n * isElement(document.createElement(\"div\")); // -> true\r\n * isElement(document.body); // -> true\r\n * isElement(document.createTextNode(\"\")); // -> false\r\n * isElement($(\"body\")); // -> false\r\n * isElement($(\"body\")[0]); // -> true\r\n */\r\nvar isElement = function (element) {\r\n\r\n    // relying on polymorphism rather than instanceof is usually wise, but in\r\n    // this situation it'd be so much eaasier to simply type:\r\n    // return element instanceof HTMLElement;\r\n    return (\r\n        element !== null\r\n        && element !== undefined\r\n        && (/^\\[object\\sHTML(?:[A-Z][a-z]+)?Element\\]$/).test(element)\r\n        && typeof element.nodeName === \"string\"\r\n        && typeof element.nodeType === \"number\"\r\n    );\r\n\r\n};\r\n\r\n// Source: \\src\\global\\memoise.js\n\r\n\r\n/**\r\n * Modifies a function so that the results are retrieved from a cache if\r\n * possible rather than from executing the function again. The cache is publicly\r\n * exposed (as the property <code>cache</code>) to allow it to be cleared,\r\n * forcing the function to re-execute.\r\n * <br><br>\r\n * If defined, the <code>resolver</code> is passed the same arguments as the\r\n * <code>handler</code>; it should return a string and that string will be used\r\n * as the key for <code>cache</code>. If a <code>resolver</code> isn't defined,\r\n * or isn't a function, the arguments are simply joined together as a\r\n * comma-separated string.\r\n *\r\n * @global\r\n * @private\r\n * @param   {Function} handler\r\n *          Function to convert.\r\n * @param   {Function} [resolver]\r\n *          Optional function for working out the key for the cache.\r\n * @return  {Function}\r\n *          Converted function.\r\n *\r\n * @example <caption>Basic example</caption>\r\n * var increase = function (number) {\r\n *     console.log(number);\r\n *     return number + 1;\r\n * };\r\n * var memIncrease = memoise(increase);\r\n *\r\n * memIncrease(1);\r\n * // Logs: 1\r\n * // -> 2\r\n * memIncrease(1); // -> 2\r\n * memincrease(2);\r\n * // Logs: 2\r\n * // -> 3\r\n * memIncrease(1); // -> 1\r\n * memIncrease.cache; // -> {\"1\": 2, \"2\": 3}\r\n *\r\n * @example <caption>Specifying a resolver</caption>\r\n * var sum = function (numbers) {\r\n *     return numbers.reduce(function (prev, curr) {\r\n *         return prev + curr;\r\n *     }, 0);\r\n * };\r\n * var memSum = memoise(sum, function (numbers) {\r\n *     return JSON.stringify(numbers);\r\n * });\r\n * memSum([1, 2, 3]); // -> 6\r\n * memSum.cache; // -> {\"[1,2,3]\": 6}\r\n */\r\nvar memoise = function (handler, resolver) {\r\n\r\n    var hasOwn = Object.prototype.hasOwnProperty;\r\n    var slice = Array.prototype.slice;\r\n    var memoised = function mem() {\r\n\r\n        var args = slice.call(arguments);\r\n        var key = typeof resolver === \"function\"\r\n            ? resolver.apply(undefined, args)\r\n            : args.join(\",\");\r\n        var response = mem.cache[key];\r\n\r\n        if (!hasOwn.call(mem.cache, key)) {\r\n\r\n            response = handler.apply(this, args);\r\n            mem.cache[key] = response;\r\n\r\n        }\r\n\r\n        return response;\r\n\r\n    };\r\n\r\n    memoised.cache = {};\r\n\r\n    return memoised;\r\n\r\n};\r\n\r\n// Source: \\src\\global\\normalise.js\n\r\n\r\n/**\r\n * Normalises a WAI-ARIA attribute name so that it's always lower case and\r\n * always stars with <code>aria-</code>. If the unprefixed value appears in\r\n * [jQuery.ariaFix]{@link external:jQuery.ariaFix} then the mapped version is\r\n * used before being prefixed.\r\n * <br><br>\r\n * The results of this function are cached to help reduce processing. This is\r\n * exposed as <code>jQuery.normaliseAria.cache</code> if needed but there is no\r\n * need to clear the cache after modifying\r\n * [jQuery.ariaFix]{@link external:jQuery.ariaFix} - changes are automatically\r\n * considered in the caching process.\r\n * <br><br>\r\n * This function is aliased as\r\n * [jQuery.normalizeAria]{@link external:jQuery.normalizeAria}.\r\n *\r\n * @function\r\n * @alias    external:jQuery.normaliseAria\r\n * @memberof external:jQuery\r\n * @param    {String} name\r\n *           Attribute name to normalise.\r\n * @return   {String}\r\n *           Normalised attribute name.\r\n * @property {Object.<String>} cache\r\n *           The cache of requests to responses.\r\n *\r\n * @example <caption>Basic example</caption>\r\n * $.normaliseAria(\"label\");      // -> \"aria-label\"\r\n * $.normaliseAria(\"LABEL\");      // -> \"aria-label\"\r\n * $.normaliseAria(\"aria-label\"); // -> \"aria-label\"\r\n * $.normaliseAria();             // -> \"aria-\"\r\n *\r\n * @example <caption>Alias</caption>\r\n * $.normalizeAria(\"label\");      // -> \"aria-label\"\r\n * $.normalizeAria(\"LABEL\");      // -> \"aria-label\"\r\n * $.normalizeAria(\"aria-label\"); // -> \"aria-label\"\r\n * $.normalizeAria();             // -> \"aria-\"\r\n *\r\n * @example <caption>Mapped attribute</caption>\r\n * // $.ariaFix = {labeledby: \"labelledby\"}\r\n * $.normaliseAria(\"labeledby\");      // -> \"aria-labelledby\"\r\n * $.normaliseAria(\"LABELEDBY\");      // -> \"aria-labelledby\"\r\n * $.normaliseAria(\"aria-labeledby\"); // -> \"aria-labelledby\"\r\n *\r\n * @example <caption>The cache</caption>\r\n * $.normaliseAria(\"busy\");    // -> \"aria-busy\"\r\n * $.normaliseAria(\"busy\");    // -> \"aria-busy\" (from cache)\r\n * $.normaliseAria(\"checked\"); // -> \"aria-checked\"\r\n * $.normaliseAria(\"busy\");    // -> \"aria-busy\" (from cache)\r\n * $.normaliseAria.cache;\r\n * // -> {\"busy\": \"aria-busy\", \"checked\": \"aria-checked\"}\r\n */\r\nvar normalise = memoise(\r\n    function (name) {\r\n\r\n        var prefix = \"aria-\";\r\n        var lower = interpretString(name).toLowerCase();\r\n        var full = (/^aria-/).test(lower)\r\n            ? lower\r\n            : prefix + lower;\r\n        var stem = full.slice(prefix.length);\r\n        var map = $.ariaFix[stem];\r\n\r\n        if (map) {\r\n\r\n            stem = map;\r\n            full = prefix + stem;\r\n\r\n        }\r\n\r\n        return full;\r\n\r\n    },\r\n    IS_PROXY_AVAILABLE\r\n        ? identity\r\n        : function (name) {\r\n\r\n            return name + \"|\" + JSON.stringify($.ariaFix);\r\n\r\n        }\r\n);\r\n\r\n// Source: \\src\\global\\toWords.js\n\r\n\r\n/**\r\n * Converts the given string into an array of the words. The <code>string</code>\r\n * argument is converted into a string before being split - see\r\n * {@link interpretString} for more information.\r\n *\r\n * @global\r\n * @private\r\n * @param   {String} string\r\n *          String (or other variable type) to break into words.\r\n * @return  {Array.<String>}\r\n *          Words from the string.\r\n *\r\n * @example\r\n * toWords(\"abc def\");  // -> [\"abc\", \"def\"]\r\n * toWords(\"abc  def\"); // -> [\"abc\", \"def\"]\r\n * toWords(\"\")          // -> []\r\n * toWords(\"   \");      // -> []\r\n */\r\nvar toWords = function (string) {\r\n\r\n    return interpretString(string).split(/\\s+/).filter(identity);\r\n\r\n};\r\n\r\n// Source: \\src\\global\\handlers.js\nvar HANDLER_PROPERTY = \"property\";\r\nvar HANDLER_REFERENCE = \"reference\";\r\nvar HANDLER_STATE = \"state\";\r\n\r\n/**\r\n * Handlers for properties, references and states. Each handler has at least a\r\n * <code>get</code> and <code>set</code> method to write and read the values.\r\n * <code>has</code> methods check whether the property exists,\r\n * <code>unset</code> removes the property.\r\n *\r\n * {@link handlers.reference} and {@link handlers.state} defer to\r\n * {@link handlers.property} (they don't inherit from {@link handlers.property}\r\n * but they may do in another implementation - any functionality they don't have\r\n * will be taken from {@link handlers.property}).\r\n *\r\n * @global\r\n * @namespace\r\n * @private\r\n */\r\nvar handlers = {};\r\n\r\n// Source: \\src\\global\\handlers\\property.js\n\r\n\r\n/**\r\n * Handles WAI-ARIA properties without modifying the values any more than it\r\n * needs to. These methods also act as the fallback for other namespaces such as\r\n * {@link handlers.reference} and {@link handlers.state}.\r\n * <br>{@link handlers.property.parse} parses the attribute name.\r\n * <br>{@link handlers.property.get} gets the value of the property.\r\n * <br>{@link handlers.property.set} sets a property.\r\n * <br>{@link handlers.property.has} checks to see if the property exists.\r\n * <br>{@link handlers.property.unset} removes the property.\r\n *\r\n * @alias     property\r\n * @memberof  handlers\r\n * @namespace\r\n * @private\r\n */\r\nhandlers[HANDLER_PROPERTY] = {\r\n\r\n    /**\r\n     * Parses the name and returns an object with the normalised name (see\r\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria} and the\r\n     * un-prefixed attribute name.\r\n     *\r\n     * @param  {String} name\r\n     *         Attribute name to parse.\r\n     * @return {Object.<String>}\r\n     *         An object with \"full\" and \"stem\" properties.\r\n     *\r\n     * @example\r\n     * handlers.property.parse(\"busy\");\r\n     * // -> {full: \"aria-busy\", stem: \"busy\"}\r\n     */\r\n    parse: function (name) {\r\n\r\n        var normal = normalise(name);\r\n\r\n        return {\r\n            full: normal,\r\n            stem: normal.slice(5)\r\n        };\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the property of an element. The <code>value</code> is unchanged\r\n     * (other than normal string coercion) and the <code>name</code> is\r\n     * normalised into a WAI-ARIA property (see\r\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}).\r\n     * <br><br>\r\n     * If <code>element</code> is not an element (see {@link isElement}) then no\r\n     * action will be taken.\r\n     * <br><br>\r\n     * If <code>value</code> is a function, it is treated like an\r\n     * {@link Attribute_callback}. This is for consistency with\r\n     * [jQuery#attr]{@link http://api.jquery.com/attr/}.\r\n     * <br><br>\r\n     * A <code>convert</code> function can also be passed. That function will\r\n     * convert <code>value</code> (if <code>value</code> is a function,\r\n     * <code>convert</code> will convert the result) before assigning it. If\r\n     * <code>convert</code> is ommitted or not a function then {@link identity}\r\n     * is used so <code>value</code> will not be changed.\r\n     *\r\n     * @private\r\n     * @param   {Element}  element\r\n     *          Element to have a property set.\r\n     * @param   {String}   name\r\n     *          WAI-ARIA property to set.\r\n     * @param   {?}        value\r\n     *          Value of the property.\r\n     * @param   {Number}   [index]\r\n     *          Optional index of <code>element</code> within the jQuery object.\r\n     *          This is needed to keep consistency with the\r\n     *          [jQuery#attr]{@link http://api.jquery.com/attr/} function and\r\n     *          should be derived rather than manually passed.\r\n     * @param   {Function} [convert=identity]\r\n     *          Optional conversion process. If ommitted, no conversion occurs.\r\n     *\r\n     * @example <caption>Setting a property</caption>\r\n     * // Markup is:\r\n     * // <div id=\"one\"></div>\r\n     *\r\n     * var element = document.getElementById(\"one\");\r\n     * handlers.property.set(element, \"label\", \"test\");\r\n     *\r\n     * // Now markup is:\r\n     * // <div id=\"one\" aria-label=\"test\"></div>\r\n     *\r\n     * @example <caption>Setting a property using a function</caption>\r\n     * // Markup is:\r\n     * // <div id=\"one\" aria-label=\"test\"></div>\r\n     *\r\n     * var element = document.getElementById(\"one\");\r\n     * handlers.property.set(element, \"label\", function (i, attr) {\r\n     *     return this.id + \"__\" + i + \"__\" + attr;\r\n     * }, 0);\r\n     *\r\n     * // Now markup is:\r\n     * // <div id=\"one\" aria-label=\"one__0__test\"></div>\r\n     *\r\n     * @example <caption>Converting the result</caption>\r\n     * // Markup is:\r\n     * // <div id=\"one\" aria-label=\"test\"></div>\r\n     *\r\n     * var element = document.getElementById(\"one\");\r\n     * handlers.property.set(element, \"label\", function (i, attr) {\r\n     *     return this.id + \"__\" + i + \"__\" + attr;\r\n     * }, 0, function (value) {\r\n     *     return value.toUpperCase();\r\n     * });\r\n     *\r\n     * // Now markup is:\r\n     * // <div id=\"one\" aria-label=\"ONE__0__TEST\"></div>\r\n     */\r\n    set: function (element, name, value, index, convert) {\r\n\r\n        var prop = handlers[HANDLER_PROPERTY].parse(name);\r\n        var hook = $.ariaHooks[prop.stem];\r\n\r\n        if (isElement(element)) {\r\n\r\n            if ($.isFunction(value)) {\r\n\r\n                value = value.call(\r\n                    element,\r\n                    index,\r\n                    element.getAttribute(prop.full)\r\n                );\r\n\r\n            }\r\n\r\n            if (!$.isFunction(convert)) {\r\n                convert = identity;\r\n            }\r\n\r\n            if (value !== undefined && value !== null) {\r\n\r\n                if (hook && hook.set) {\r\n                    value = hook.set(element, value, prop.full);\r\n                }\r\n\r\n                value = convert(value);\r\n\r\n                if (value !== undefined && value !== null) {\r\n                    element.setAttribute(prop.full, interpretString(value));\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Checks to see if the given <code>name</code> exists on the given\r\n     * <code>element</code>. The <code>name</code> is always normalised (see\r\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}) and if\r\n     * <code>element</code> is not an element (see {@link isElement}) then\r\n     * <code>false</code> will always be returned.\r\n     *\r\n     * @private\r\n     * @param   {Element} element\r\n     *          Element to test.\r\n     * @param   {String}  name\r\n     *          WAI-ARIA property to check.\r\n     * @return  {Boolean}\r\n     *          Whether or not the element has the given property.\r\n     *\r\n     * @example\r\n     * // Markup is:\r\n     * // <div id=\"one\" aria-label=\"test\"></div>\r\n     *\r\n     * var element = document.getElementById(\"one\");\r\n     * handlers.property.has(element, \"label\"); // -> true\r\n     * handlers.property.has(element, \"busy\");  // -> false\r\n     */\r\n    has: function (element, name) {\r\n\r\n        var prop = handlers[HANDLER_PROPERTY].parse(name);\r\n        var hook = $.ariaHooks[prop.stem];\r\n\r\n        return isElement(element)\r\n            ? (hook && hook.has)\r\n                ? hook.has(element, prop.full)\r\n                : element.hasAttribute(prop.full)\r\n            : false;\r\n\r\n    },\r\n\r\n    /**\r\n     * Gets the value of the WAI-ARIA property from the given\r\n     * <code>element</code> and returns it unchanged. The <code>name</code> is\r\n     * normalised (see\r\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). If\r\n     * <code>element</code> is not an element (see {@link isElement}) or\r\n     * <code>name</code> is not recognised (see\r\n     * {@link handlers.property.has}) then <code>undefined</code> is returned.\r\n     *\r\n     * @private\r\n     * @param   {Element}          element\r\n     *          Element to access.\r\n     * @param   {String}           name\r\n     *          WAI-ARIA property to access.\r\n     * @return  {String|undefined}\r\n     *          WAI-ARIA attribute or undefined if the attribute isn't set.\r\n     *\r\n     * @example\r\n     * // Markup is:\r\n     * // <div id=\"one\" aria-label=\"test\"></div>\r\n     *\r\n     * var element = document.getElementById(\"one\");\r\n     * handlers.property.get(element, \"label\"); // -> \"test\"\r\n     * handlers.property.get(element, \"busy\"); // -> undefined\r\n     */\r\n    get: function (element, name) {\r\n\r\n        var handler = handlers[HANDLER_PROPERTY];\r\n        var prop = handler.parse(name);\r\n        var hook = $.ariaHooks[prop.stem];\r\n        var response = handler.has(element, name)\r\n            ? (hook && hook.get)\r\n                ? hook.get(element, prop.full)\r\n                : element.getAttribute(prop.full)\r\n            : undefined;\r\n\r\n        // getAttribute can return null, normalise to undefined.\r\n        return response === null\r\n            ? undefined\r\n            : response;\r\n\r\n    },\r\n\r\n    /**\r\n     * Removes a WAI-ARIA attribute from the given <code>element</code>. The\r\n     * <code>name</code> if normalised (see\r\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}) and if\r\n     * <code>element</code> is not an element (see {@link isElement}) then no\r\n     * action is taken.\r\n     *\r\n     * @private\r\n     * @param   {Element} element\r\n     *          Element to modify.\r\n     * @param   {String}  name\r\n     *          WAI-ARIA attribute to remove.\r\n     *\r\n     * @example\r\n     * // Markup is:\r\n     * // <div id=\"one\" aria-label=\"test\"></div>\r\n     *\r\n     * var element = document.getElementById(\"one\");\r\n     * handlers.property.unset(element, \"label\");\r\n     *\r\n     * // Now markup is:\r\n     * // <div id=\"one\"></div>\r\n     */\r\n    unset: function (element, name) {\r\n\r\n        var prop = handlers[HANDLER_PROPERTY].parse(name);\r\n        var hook = $.ariaHooks[prop.stem];\r\n\r\n        if (isElement(element)) {\r\n\r\n            if (!hook || !hook.unset || hook.unset(element, prop.full)) {\r\n                element.removeAttribute(prop.full);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n};\r\n\r\n// Source: \\src\\global\\handlers\\reference.js\n\r\n\r\n/**\r\n * Handles modifying WAI-ARIA references. Unlike {@link handlers.property}, this\r\n * will create references to elements and return them. The only defined methods\r\n * are:\r\n * <br>{@link handlers.reference.set} sets a reference.\r\n * <br>{@link handlers.reference.get} gets a reference.\r\n *\r\n * @alias     reference\r\n * @memberof  handlers\r\n * @namespace\r\n * @private\r\n */\r\nhandlers[HANDLER_REFERENCE] = {\r\n\r\n    /**\r\n     * Adds the WAI-ARIA reference to <code>element</code>. This differs from\r\n     * {@link handlers.property.set} in that <code>reference</code> is passed\r\n     * through [jQuery's $ function]{@link http://api.jquery.com/jquery/} and\r\n     * identified (see [jQuery#identify]{@link external:jQuery#identify}) with\r\n     * the ID of the first match being used. There is also no\r\n     * <code>convert</code> parameter.\r\n     * <br><br>\r\n     * The <code>name</code> is still normalised (see\r\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). If\r\n     * <code>element</code> is not an element (see {@link isElement}) then no\r\n     * action is taken.\r\n     *\r\n     * @private\r\n     * @param   {Element}      element\r\n     *          Element to modify.\r\n     * @param   {String}       name\r\n     *          WAI-ARIA attribute to set.\r\n     * @param   {jQuery_param} reference\r\n     *          Element to reference.\r\n     * @param   {Number}       index\r\n     *          Index of <code>element</code> within the collection.\r\n     *\r\n     * @example\r\n     * // Markup is:\r\n     * // <div class=\"one\"></div>\r\n     * // <div class=\"two\"></div>\r\n     *\r\n     * var element = document.querySelector(\".one\");\r\n     * handlers.reference.set(element, \"labelledby\", \".two\");\r\n     *\r\n     * // Now markup is:\r\n     * // <div class=\"one\" aria=labelledby=\"anonymous0\"></div>\r\n     * // <div class=\"two\" id=\"anonymous0\"></div>\r\n     */\r\n    set: function (element, name, reference, index) {\r\n\r\n        handlers[HANDLER_PROPERTY].set(\r\n            element,\r\n            name,\r\n            reference,\r\n            index,\r\n            identify\r\n        );\r\n\r\n    },\r\n\r\n    /**\r\n     * Gets the reference from the given <code>element</code> and returns it as\r\n     * a <code>jQuery</code> object. This differs from\r\n     * {@link handlers.property.get} in that the match is assumed to be an ID\r\n     * and a DOM lookup is done based upon that. The <code>name</code> is still\r\n     * normalised (see\r\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). If the\r\n     * WAI-ARIA attribute is not found (see {@link handlers.property.has} then\r\n     * <code>undefined</code> is returned.\r\n     *\r\n     * @private\r\n     * @param   {Element}          element\r\n     *          Element to check.\r\n     * @param   {String}           name\r\n     *          WAI-ARIA reference.\r\n     * @return  {jQuery|undefined}\r\n     *          jQuery object representing the reference or undefined if the\r\n     *          attribute isn't set.\r\n     *\r\n     * @example\r\n     * // Markup is:\r\n     * // <div id=\"one\" aria=labelledby=\"two\"></div>\r\n     * // <div id=\"two\"></div>\r\n     *\r\n     * var element = document.getElementById(\"one\");\r\n     * handlers.reference.get(element, \"labelledby\");\r\n     * // -> $(<div id=\"two\">)\r\n     * handlers.reference.get(element, \"controls\");\r\n     * // -> undefined\r\n     */\r\n    get: function (element, name) {\r\n\r\n        var handler = handlers[HANDLER_PROPERTY];\r\n\r\n        return handler.has(element, name)\r\n            ? $(\"#\" + handler.get(element, name))\r\n            : undefined;\r\n\r\n    }\r\n\r\n};\r\n\r\n// Source: \\src\\global\\handlers\\state.js\n\r\n\r\nvar REGEXP_BOOLEAN = /^(?:true|false)$/;\r\nvar VALUE_MIXED = \"mixed\";\r\n\r\n/**\r\n * Handles WAI-ARIA states. This differs from {@link handlers.property} in that\r\n * values are coerced into booleans before being set and a boolean (or the\r\n * string \"mixed\") will be returned.\r\n * <br>{@link handlers.state.read} converts the value into a boolean.\r\n * <br>{@link handlers.state.set} sets the state.\r\n * <br>{@link handlers.state.get} gets the state.\r\n *\r\n * @alias     state\r\n * @memberof  handlers\r\n * @namespace\r\n * @private\r\n */\r\nhandlers[HANDLER_STATE] = {\r\n\r\n    /**\r\n     * Reads the raw value and converts it into a boolean or the string\r\n     * <code>\"mixed\"</code> (always lower case). If <code>raw</code> cannot be\r\n     * correctly converted, it is assumed to be <code>true</code>.\r\n     *\r\n     * @private\r\n     * @param   {?} raw\r\n     *          Value to read.\r\n     * @return  {Boolean|String}\r\n     *          Converted value.\r\n     *\r\n     * @example <caption>Converting values</caption>\r\n     * handlers.state.read(true);    // -> true\r\n     * handlers.state.read(\"false\"); // -> false\r\n     * handlers.state.read(\"1\");     // -> true\r\n     * handlers.state.read(0);       // -> false\r\n     * handlers.state.read(\"mixed\"); // -> \"mixed\"\r\n     *\r\n     * @example <caption>Unrecognised values default to true</caption>\r\n     * handlers.state.read(\"2\");      // -> true\r\n     * handlers.state.read(-1);       // -> true\r\n     * handlers.state.read([]);       // -> true\r\n     * handlers.state.read(\"mixed.\"); // -> true\r\n     */\r\n    read: function readState(raw) {\r\n\r\n        var state = true;\r\n\r\n        switch (typeof raw) {\r\n\r\n        case \"boolean\":\r\n\r\n            state = raw;\r\n            break;\r\n\r\n        case \"string\":\r\n\r\n            raw = raw.toLowerCase();\r\n\r\n            if (raw === VALUE_MIXED) {\r\n                state = raw;\r\n            } else if (raw === \"1\" || raw === \"0\") {\r\n                state = readState(+raw);\r\n            } else if (REGEXP_BOOLEAN.test(raw)) {\r\n                state = raw === \"true\";\r\n            }\r\n\r\n            break;\r\n\r\n        case \"number\":\r\n\r\n            if (raw === 0 || raw === 1) {\r\n                state = !!raw;\r\n            }\r\n\r\n            break;\r\n\r\n        }\r\n\r\n        return state;\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the WAI-ARIA state defined in <code>name</code> on the given\r\n     * <code>element</code>. This differs from {@link handlers.property.set} in\r\n     * that <code>state</code> is converted into a boolean or\r\n     * <code>\"mixed\"</code> before being assigned (see\r\n     * {@link handlers.state.read}) and there is no <code>convert</code>\r\n     * paramter. The <code>name</code> is still normalised (see\r\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}).\r\n     *\r\n     * @private\r\n     * @param   {Element} element\r\n     *          Element to modify.\r\n     * @param   {String}  name\r\n     *          WAI-ARIA attribute to set.\r\n     * @param   {?}       state\r\n     *          State to set.\r\n     * @param   {Number}  index\r\n     *          Index of <code>element</code> within the collection.\r\n     *\r\n     * @example\r\n     * // Markup is:\r\n     * // <div id=\"one\"></div>\r\n     * // <div id=\"two\"></div>\r\n     *\r\n     * var one = document.getElementById(\"one\");\r\n     * var two = document.getElementById(\"two\");\r\n     * handlers.state.set(one, \"busy\", true);\r\n     * handlers.state.set(two, \"checked\", \"mixed\");\r\n     *\r\n     * // Now markup is:\r\n     * // <div id=\"one\" aria-busy=\"true\"></div>\r\n     * // <div id=\"two\" aria-checked=\"mixed\"></div>\r\n     */\r\n    set: function (element, name, state, index) {\r\n\r\n        handlers[HANDLER_PROPERTY].set(\r\n            element,\r\n            name,\r\n            state,\r\n            index,\r\n            handlers[HANDLER_STATE].read\r\n        );\r\n\r\n    },\r\n\r\n    /**\r\n     * Reads the WAI-ARIA state on <code>element</code>. This differs from\r\n     * {@link handlers.property.get} in that the result is converted into a\r\n     * boolean or the strign `\"mixed\"` before being returned. The\r\n     * <code>name</code> is still normalised (see {@link jQuery.normaliseAria}).\r\n     *\r\n     * @private\r\n     * @param   {Element}    element\r\n     *          Element to access.\r\n     * @param   {String}     name\r\n     *          WAI-ARIA state to read.\r\n     * @return  {ARIA_state}\r\n     *          State of the WAI-ARIA property.\r\n     *\r\n     * @example\r\n     * // Markup is:\r\n     * // <div id=\"one\" aria-busy=\"true\" aria-checked=\"mixed\"></div>\r\n     *\r\n     * var element = document.getElementById(\"one\");\r\n     * handlers.state.get(element, \"busy\");     // -> true\r\n     * handlers.state.get(element, \"checked\");  // -> \"mixed\"\r\n     * handlers.state.get(element, \"disabled\"); // -> undefined\r\n     */\r\n    get: function (element, name) {\r\n\r\n        var handler = handlers[HANDLER_PROPERTY];\r\n        var state;\r\n        var value;\r\n\r\n        if (handler.has(element, name)) {\r\n\r\n            value = handler.get(element, name).toLowerCase();\r\n            state = value === VALUE_MIXED\r\n                ? value\r\n                : (REGEXP_BOOLEAN.test(value) && value === \"true\");\r\n\r\n        }\r\n\r\n        return state;\r\n\r\n    }\r\n\r\n};\r\n\r\n// Source: \\src\\global\\access.js\n\r\n\r\n/**\r\n * This function handles all the heavy lifting of getting or setting WAI-ARIA\r\n * attributes. It is designed to be all that's necessary for\r\n * [jQuery#aria]{@link external:jQuery#aria},\r\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef} and\r\n * [jQuery#ariaState]{@link external:jQuery#ariaState}. This function will check\r\n * its arguments to determine whether it should be used as a getter or a setter\r\n * and passes the appropriate arguments to the {@link handlers} methods based on\r\n * <code>type</code> (which will default to {@link handlers.property} if\r\n * ommitted or not recognised).\r\n * <br><br>\r\n * The return value is based on the type of action being performed. If this\r\n * function is setting then a jQuery object of the matches is returned (which is\r\n * almost always <code>jQelements</code>); if the function is a getter then the\r\n * results are returned for the first element in <code>jQelements</code>.\r\n * <br><br>\r\n * Although this description is not especially extensive, the code should be\r\n * very easy to follow and commented should there be any need to modify it. Once\r\n * the correct arguments are being passed to the appropriate {@link handlers}\r\n * method, they will take care of the rest.\r\n *\r\n * @global\r\n * @private\r\n * @param   {jQuery}            jQelements\r\n *          jQuery object to modify/access.\r\n * @param   {Object|String}     property\r\n *          Either WAI-ARIA names and values or the WAI-ARIA property name.\r\n * @param   {?}                 [value]\r\n *          Value to set.\r\n * @param   {String}            [type=\"property\"]\r\n *          Optional attribute type.\r\n * @return  {jQuery|ARIA_state}\r\n *          Either the jQuery object on which WAI-ARIA properties were set or\r\n *          the values of the WAI-ARIA properties.\r\n *\r\n * @example <caption>Setting a single property</caption>\r\n * // Markup is\r\n * // <div id=\"one\"></div>\r\n *\r\n * var jQone = $(\"#one\");\r\n * access(jQone, \"controls\", \"two\"); // -> jQuery(<div id=\"one\">)\r\n *\r\n * // Now markup is\r\n * // <div id=\"one\" aria-controls=\"two\">\r\n *\r\n * @example <caption>Setting multiple references</caption>\r\n * // Markup is\r\n * // <div id=\"one\"></div>\r\n * // <div id=\"two\"></div>\r\n *\r\n * var jQone = $(\"#one\");\r\n * access(jQone, {\r\n *     controls: $(\"div\").eq(1)\r\n * }, \"reference\"); // -> jQuery(<div id=\"one\">)\r\n *\r\n * // Now markup is\r\n * // <div id=\"one\" aria-controls=\"two\">\r\n * // <div id=\"two\"></div>\r\n *\r\n * @example <caption>Getting a state</caption>\r\n * // Markup is\r\n * // <div id=\"one\" aria-busy=\"true\"></div>\r\n *\r\n * var jQone = $(\"#one\");\r\n * access(jQone, \"busy\", undefined, \"state\"); // -> true\r\n */\r\nfunction access(jQelements, property, value, type) {\r\n\r\n    var tempProperty = property;\r\n    var isPropertyObject = $.isPlainObject(property);\r\n    var isGet = value === undefined && !isPropertyObject;\r\n\r\n    // Make sure the property value is in the expected format: an object for\r\n    // setting and a string for getting.\r\n    if (!isGet && !isPropertyObject) {\r\n\r\n        property = {};\r\n        property[tempProperty] = value;\r\n\r\n    }\r\n\r\n    // If we don't have or don't recognise the type, default to \"property\".\r\n    if (!type || !handlers[type]) {\r\n        type = HANDLER_PROPERTY;\r\n    }\r\n\r\n    return isGet\r\n        ? handlers[type].get(jQelements[0], property)\r\n        : jQelements.each(function (index, element) {\r\n\r\n            $.each(property, function (key, val) {\r\n                handlers[type].set(element, key, val, index);\r\n            });\r\n\r\n        });\r\n\r\n}\r\n\r\n// Source: \\src\\global\\removeAttribute.js\n\r\n\r\n\r\n/**\r\n * Removes the named WAI-ARIA attribute from all elements in the current\r\n * collection. The <code>name</code> is normalised (see\r\n * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). This function\r\n * is aliased as [jQuery#removeAriaRef]{@link external:jQuery#removeAriaRef} and\r\n * [jQuery#removeAriaState]{@link external:jQuery#removeAriaState}.\r\n *\r\n * @alias    removeAria\r\n * @memberof external:jQuery\r\n * @instance\r\n * @param    {String} name\r\n *           WAI-ARIA attribute to remove.\r\n * @return   {jQuery}\r\n *           jQuery attribute representing the elements modified.\r\n *\r\n * @example\r\n * // Markup is\r\n * // <div id=\"one\" aria-busy=\"true\"></div>\r\n *\r\n * $(\"#one\").removeAria(\"busy\"); // -> jQuery(<div id=\"one\">)\r\n *\r\n * // Now markup is:\r\n * // <div id=\"one\"></div>\r\n */\r\nfunction removeAttribute(name) {\r\n\r\n    return this.each(function (ignore, element) {\r\n        handlers[HANDLER_PROPERTY].unset(element, name);\r\n    });\r\n\r\n}\r\n\r\n// Source: \\src\\member\\normaliseAria.js\n\r\n\r\n/**\r\n * Alias of [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}\r\n *\r\n * @function\r\n * @alias    external:jQuery.normalizeAria\r\n * @memberof external:jQuery\r\n * @param    {String} name\r\n *           Attribute name to normalise.\r\n * @return   {String}\r\n *           Normalised attribute name.\r\n * @property {Object.<String>} cache\r\n *           The cache of requests to responses.\r\n */\r\n$.normalizeAria = normalise;\r\n$.normaliseAria = normalise;\r\n\r\n// Source: \\src\\member\\ariaFix.js\n\r\n\r\n/**\r\n * A map of unprefixed WAI-ARIA attributes that should be converted before being\r\n * normalised (see [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}).\r\n *\r\n * @alias    external:jQuery.ariaFix\r\n * @memberof external:jQuery\r\n * @type     {Object.<String>}\r\n *\r\n * @example <caption>Correcting a common typo</caption>\r\n * $.ariaFix.budy = \"busy\";\r\n * $.normaliseAria(\"budy\");      // -> \"aria-busy\"\r\n * $.normaliseAria(\"aria-budy\"); // -> \"aria-busy\"\r\n */\r\n$.ariaFix = {\r\n\r\n    // This is the US English spelling but the accessibility API defined the\r\n    // attribute with the double L.\r\n    // https://www.w3.org/TR/wai-aria/states_and_properties#aria-labelledby\r\n    labeledby: \"labelledby\"\r\n\r\n};\r\n\r\n// If Proxy is available, we can use it to check whenever $.ariaFix is modified\r\n// and invalidate the cache of normalise() when it is. This is a lot more\r\n// efficient than always converting $.ariaFix to a JSON string to ensure the\r\n// cache is accurate.\r\nif (IS_PROXY_AVAILABLE) {\r\n\r\n    $.ariaFix = new Proxy($.ariaFix, {\r\n\r\n        set: function (target, name, value) {\r\n\r\n            normalise.cache = {};\r\n            target[name] = value;\r\n\r\n        }\r\n\r\n    });\r\n\r\n}\r\n\r\n// Source: \\src\\member\\ariaHooks.js\n\r\n\r\n/**\r\n * A collection of hooks that change the behaviour of attributes being set,\r\n * retrieved, checked or removed (called [set]{@link ARIA_hook_set},\r\n * [get]{@link ARIA_hook_get}, [has]{@link ARIA_hook_has},\r\n * [unset]{@link ARIA_hook_unset} - see {@link ARIA_hook} for full details). The\r\n * name of the hook is always the un-prefixed WAI-ARIA attribute in lower case\r\n * after any mapping has occurred (see\r\n * [jQuery.ariaFix]{@link external:jQuery.ariaFix}). If you are ever in doubt,\r\n * the easiest way to know the key is to slice the normalised value:\r\n * <code>$.normaliseAria(__WAI-ARIA_ATTRIBUTE__).slice(5)</code> (see\r\n * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria} for more\r\n * information).\r\n * <br><br>\r\n * Do not use these functions to set different WAI-ARIA attributes without\r\n * setting the one being passed to the aria method; for example: do not create a\r\n * set for \"attribute1\" that sets \"attribute2\" instead - unless you add the same\r\n * conversion to <code>has</code>, <code>get</code> will not be triggered.\r\n * Instead, use [jQuery.ariaFix]{@link external:jQuery.ariaFix} to convert the\r\n * attribute name.\r\n * <br><br>\r\n * [jQuery#aria]{@link external:jQuery#aria},\r\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef},\r\n * [jQuery#ariaState]{@link external:jQuery#ariaState},\r\n * [jQuery#removeAria]{@link external:jQuery#removeAria},\r\n * [jQuery#removeAriaRef]{@link external:jQuery#removeAriaRef} and\r\n * [jQuery#removeAriaState]{@link external:jQuery#removeAriaState} all run\r\n * through these hooks (if they exist) and these hooks replace the functionality\r\n * of manipulating or checking the attributes after any conversion process has\r\n * occurred within the method itself.\r\n *\r\n * @alias    external:jQuery.ariaHooks\r\n * @memberof external:jQuery\r\n * @type     {Object.<ARIA_hook>}\r\n *\r\n * @example\r\n * // aria-level should be an integer greater than or equal to 1 so the getter\r\n * // should return an integer.\r\n * $.ariaHooks.level = {\r\n *     set: function (element, value) {\r\n *         var intVal = Math.max(1, Math.floor(value));\r\n *         if (!isNaN(intVal)) {\r\n *             element.setAttribute(\"aria-level\", intVal)\r\n *         }\r\n *     },\r\n *     get: function (element) {\r\n *         var value = element.getAttribute(\"aria-level\");\r\n *         var intVal = Math.max(1, Math.floor(value));\r\n *         return (value === null || isNaN(intVal))\r\n *             ? undefined\r\n *             : intVal;\r\n *     }\r\n * };\r\n */\r\n$.ariaHooks = {\r\n\r\n    hidden: {\r\n\r\n        // Setting aria-hidden=\"false\" is considered valid, but removing the\r\n        // aria-hidden attribute has the same effect and I think it's tidier.\r\n        // https://www.w3.org/TR/wai-aria/states_and_properties#aria-hidden\r\n        set: function (element, value, name) {\r\n\r\n            var response;\r\n\r\n            if (value === false || +value === 0 || (/^false$/i).test(value)) {\r\n                element.removeAttribute(name);\r\n            } else {\r\n                response = value;\r\n            }\r\n\r\n            return response;\r\n\r\n        }\r\n\r\n    }\r\n\r\n};\r\n\r\n// Source: \\src\\instance\\identify.js\n\r\n\r\n\r\nvar count = 0;\r\n\r\n/**\r\n * Identifies the first element in the collection by getting its ID. If the\r\n * element doesn't have an ID attribute, a unique on is generated and assigned\r\n * before being returned. If the collection does not have a first element then\r\n * <code>undefined</code> is returned.\r\n * <br><br>\r\n * IDs are a concatenation of \"anonymous\" and a hidden counter that is increased\r\n * each time. If the ID already exists on the page, that ID is skipped and not\r\n * assigned to a second element.\r\n *\r\n * @memberof external:jQuery\r\n * @instance\r\n * @alias    identify\r\n * @return   {String|undefined}\r\n *           The ID of the first element or undefined if there is no first\r\n *           element.\r\n *\r\n * @example <caption>Identifying elements</caption>\r\n * // Markup is\r\n * // <div class=\"one\"></div>\r\n * // <span class=\"one\"></span>\r\n *\r\n * $(\".one\").identify(); // -> \"anonymous0\"\r\n *\r\n * // Now markup is:\r\n * // <div class=\"one\" id=\"anonymous0\"></div>\r\n * // <span class=\"one\"></span>\r\n * // Running $(\".one\").identify(); again would not change the markup.\r\n *\r\n * @example <caption>Existing IDs are not duplicated</caption>\r\n * // Markup is:\r\n * // <div class=\"two\" id=\"anonymous1\"><!-- manually set --></div>\r\n * // <div class=\"two\"></div>\r\n * // <div class=\"two\"></div>\r\n *\r\n * $(\".two\").each(function () {\r\n *     $(this).identify();\r\n * });\r\n *\r\n * // Now markup is:\r\n * // <div class=\"two\" id=\"anonymous1\"><!-- manually set --></div>\r\n * // <div class=\"two\" id=\"anonymous0\"></div>\r\n * // <div class=\"two\" id=\"anonymous2\"></div>\r\n */\r\n$.fn.identify = function () {\r\n\r\n    var element = this[0];\r\n    var isAnElement = isElement(element);\r\n    var id = isAnElement\r\n        ? element.id\r\n        : undefined;\r\n\r\n    if (isAnElement && !id) {\r\n\r\n        do {\r\n\r\n            id = \"anonymous\" + count;\r\n            count += 1;\r\n\r\n        } while (document.getElementById(id));\r\n\r\n        element.id = id;\r\n\r\n    }\r\n\r\n    return id;\r\n\r\n};\r\n\r\n// Source: \\src\\instance\\aria.js\n\r\n\r\n\r\n/**\r\n * Gets or sets WAI-ARIA properties. The properties will not be modified any\r\n * more than they need to be (unlike\r\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef} or\r\n * [jQuery#ariaState]{@link external:jQuery#ariaState} which will interpret the\r\n * values).\r\n * <br><br>\r\n * To set WAI-ARIA properties, pass either a\r\n * <code>property</code>/<code>value</code> pair of arguments or an object\r\n * containing those pairs. When this is done, the attributes are set on all\r\n * elements in the collection and the <code>jQuery</code> object is returned to\r\n * allow for chaining. If <code>value</code> is a function and returns\r\n * <code>undefined</code> (or nothing) then no action is taken for that element.\r\n * This can be useful for selectively setting values only when certain criteria\r\n * are met.\r\n * <br><br>\r\n * To get WAI-ARIA properties, only pass the <code>property</code> that you want\r\n * to get. If there is no matching property, <code>undefined</code> is returned.\r\n * All properties are normalised (see\r\n * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}).\r\n *\r\n * @memberof external:jQuery\r\n * @instance\r\n * @alias    aria\r\n * @param    {Object|String} property\r\n *           Either the properties to set in key/value pairs or the name of the\r\n *           property to get/set.\r\n * @param    {Attribute_Callback|Boolean|Number|String} [value]\r\n *           The value of the property to set.\r\n * @return   {jQuery|String|undefined}\r\n *           Either the jQuery object (after setting) or a string or undefined\r\n *           (after getting)\r\n *\r\n * @example <caption>Setting WAI-ARIA attribute(s)</caption>\r\n * $(\"#element\").aria(\"aria-label\", \"test\");\r\n * // or\r\n * $(\"#element\").aria(\"label\", \"test\");\r\n * // or\r\n * $(\"#element\").aria({\r\n *     \"aria-label\": \"test\"\r\n * });\r\n * // or\r\n * $(\"#element\").aria({\r\n *     label: \"test\"\r\n * });\r\n * // All of these set aria-label=\"test\" on all matching elements and return a\r\n * // jQuery object representing \"#element\"\r\n *\r\n * @example <caption>Setting WAI-ARIA attribute(s) with a function</caption>\r\n * $(\"#element\").aria(\"label\", function (i, attr) {\r\n *     return this.id + \"__\" + i + \"__\" + attr;\r\n * });\r\n * // or\r\n * $(\"#element\").aria({\r\n *     label: function (i, attr) {\r\n *         return this.id + \"__\" + i + \"__\" + attr;\r\n *     }\r\n * });\r\n * // Both of these set aria-label=\"element__0__undefined\" on all matching\r\n * // elements and return a jQuery object representing \"#element\"\r\n *\r\n * @example <caption>Getting a WAI-ARIA attribute</caption>\r\n * // Markup is:\r\n * // <div id=\"element\" aria-label=\"test\"></div>\r\n * $(\"#element\").aria(\"label\");   // -> \"test\"\r\n * $(\"#element\").aria(\"checked\"); // -> undefined\r\n * // If \"#element\" matches multiple elements, the attributes from the first\r\n * // element are returned.\r\n *\r\n * @example <caption>Setting with aria methods</caption>\r\n * // Markup is:\r\n * // <div class=\"one\"></div>\r\n * // <div class=\"two\"></div>\r\n * // <div class=\"three\"</div>\r\n *\r\n * var settings = {\r\n *     busy: 0,\r\n *     controls: \".one\",\r\n *     label: \"lorem ipsum\"\r\n * };\r\n *\r\n * $(\".one\").aria(settings);\r\n * $(\".two\").ariaRef(settings);\r\n * $(\".three\").ariaState(settings);\r\n *\r\n * // Now markup is:\r\n * // <div class=\"one\"\r\n * //     aria-busy=\"0\"\r\n * //     aria-controls=\".one\"\r\n * //     aria-label=\"lorem ipsum\"\r\n * //     id=\"anonymous0\"></div>\r\n * // <div class=\"two\"\r\n * //     aria-controls=\"anonymous0\"></div>\r\n * // <div class=\"three\"\r\n * //     aria-busy=\"false\"\r\n * //     aria-controls=\"true\"\r\n * //     aria-label=\"true\"></div>\r\n *\r\n * @example <caption>Getting with aria methods</caption>\r\n * // Markup is:\r\n * // <div id=\"test\" aria-flowto=\"false\"></div>\r\n * // <div id=\"false\"></div>\r\n *\r\n * $(\"#test\").aria(\"flowto\");      // -> \"false\"\r\n * $(\"#test\").ariaRef(\"flowto\");   // -> jQuery(<div id=\"false\">)\r\n * $(\"#test\").ariaState(\"flowto\"); // -> false\r\n */\r\n$.fn.aria = function (property, value) {\r\n\r\n    return access(\r\n        this,\r\n        property,\r\n        value\r\n    );\r\n\r\n};\r\n\r\n// Source: \\src\\instance\\ariaRef.js\n\r\n\r\n\r\n/**\r\n * Gets or sets a WAI-ARIA reference. This is functionally identical to\r\n * [jQuery#aria]{@link external:jQuery#aria} with the main difference being that\r\n * an element may be passed as the <code>value</code> when setting and that a\r\n * jQuery object is returned when getting.\r\n * <br><br>\r\n * Because WAI-ARIA references work with IDs, IDs are worked out using\r\n * [jQuery#identify]{@link external:jQuery#identify}. Be aware that any string\r\n * passed to [jQuery#ariaRef]{@link external:jQuery#ariaRef} will be treated\r\n * like a CSS selector and looked up with the results being used to set the\r\n * property. If you already have the ID and wish to set it without the lookup,\r\n * use [jQuery#aria]{@link external:jQuery#aria}.\r\n * <br><br>\r\n * If <code>value</code> is a function then the resulting value is identified.\r\n * This can be particularly useful for performing DOM traversal to find the\r\n * reference (see examples below). As with\r\n * [jQuery#aria]{@link external:jQuery#aria}, if the <code>value</code> function\r\n * returns nothing or returns <code>undefined</code> then no action is taken.\r\n * <br><br>\r\n * When accessing the attribute using this function, a <code>jQuery</code>\r\n * object representing the reference is returned. If there are multiple elements\r\n * in the collection, only the reference for the first element is returned. To\r\n * get the value of the attribute rather than the element, use\r\n * [jQuery#aria]{@link external:jQuery#aria}.\r\n *\r\n * @memberof external:jQuery\r\n * @instance\r\n * @alias    ariaRef\r\n * @param    {Object|String} property\r\n *           Either the properties to set in key/value pairs or the name of the\r\n *           property to set.\r\n * @param    {Attribute_Callback|jQuery_param} [value]\r\n *           Reference to set.\r\n * @return   {jQuery}\r\n *           jQuery object representing either the elements that were modified\r\n *           (when setting) or the referenced element(s) (when getting - may be\r\n *           an empty jQuery object).\r\n *\r\n * @example <caption>Setting references</caption>\r\n * // Markup is:\r\n * // <h1>Heading</h1>\r\n * // <div class=\"one\">\r\n * //     Lorem ipsum dolor sit amet ...\r\n * // </div>\r\n *\r\n * $(\".one\").ariaRef(\"labelledby\", $(\"h1\"));\r\n * // or\r\n * $(\".one\").ariaRef(\"labelledby\", \"h1\");\r\n * // or\r\n * $(\".one\").ariaRef(\"labelledby\", $(\"h1\")[0]);\r\n * // or\r\n * $(\".one\").ariaRef({\r\n *     labelledby: $(\"h1\") // or \"h1\" or $(\"h1\")[0]\r\n * });\r\n * // Each of these return a jQuery object representing \".one\"\r\n *\r\n * // Now markup is:\r\n * // <h1 id=\"anonymous0\">Heading</h1>\r\n * // <div class=\"one\" aria-labelledby=\"anonymous0\">\r\n * //     Lorem ipsum dolor sit amet ...\r\n * // </div>\r\n *\r\n * @example <caption>Setting references with a function</caption>\r\n * // Markup is:\r\n * // <div class=\"js-collapse\">\r\n * //     <div class=\"js-collapse-content\">\r\n * //         Lorem ipsum dolor sit amet ...\r\n * //     </div>\r\n * //     <button class=\"js-collapse-toggle\">\r\n * //         Toggle\r\n * //     </button>\r\n * // </div>\r\n *\r\n * $(\".js-collapse-toggle\").ariaRef(\"controls\", function (i, attr) {\r\n *\r\n *     return $(this)\r\n *         .closest(\".js-collapse\")\r\n *         .find(\".js-collapse-content\");\r\n *\r\n * });\r\n *\r\n * // Now markup is:\r\n * // <div class=\"js-collapse\">\r\n * //     <div class=\"js-collapse-content\" id=\"anonymous0\">\r\n * //         Lorem ipsum dolor sit amet ...\r\n * //     </div>\r\n * //     <button class=\"js-collapse-toggle\" aria-controls=\"anonymous0\">\r\n * //         Toggle\r\n * //     </button>\r\n * // </div>\r\n *\r\n * @example <caption>Getting a reference</caption>\r\n * // Markup is:\r\n * // <h1 id=\"anonymous0\">Heading</h1>\r\n * // <div class=\"one\" aria-labelledby=\"anonymous0\">\r\n * //     Lorem ipsum dolor sit amet ...\r\n * // </div>\r\n *\r\n * $(\".one\").ariaRef(\"labelledby\"); // -> $(<h1>)\r\n * $(\".one\").ariaRef(\"controls\");   // -> $()\r\n *\r\n * @example <caption>Value is treated like a CSS selector</caption>\r\n * // Markup is:\r\n * // <button id=\"button\"></button>\r\n * // <div id=\"section\"></div>\r\n * // <section></section>\r\n *\r\n * $(\"#button\").ariaRef(\"controls\", \"section\");\r\n *\r\n * // Now markup is:\r\n * // <button id=\"button\" aria-controls=\"anonymous0\"></button>\r\n * // <div id=\"section\"></div>\r\n * // <section id=\"anonymous0\"></section>\r\n */\r\n$.fn.ariaRef = function (property, value) {\r\n\r\n    return access(\r\n        this,\r\n        property,\r\n        value,\r\n        HANDLER_REFERENCE\r\n    );\r\n\r\n};\r\n\r\n// Source: \\src\\instance\\ariaState.js\n\r\n\r\n\r\n/**\r\n * Sets or gets the WAI-ARIA state of the collection.\r\n * <br><br>\r\n * When setting the state, false, \"false\" (any case), 0 and \"0\" will be\r\n * considered false. All other values will be considered true except for \"mixed\"\r\n * (any case) which will set the state to \"mixed\". The differs from\r\n * [jQuery#aria]{@link external:jQuery#aria} which will simply set the\r\n * attribute(s) without converting the value.\r\n * <br><br>\r\n * After setting the state(s), a jQuery object representing the affected\r\n * elements is returned. The state for the first matching element is returned\r\n * when getting.\r\n * <br><br>\r\n * All attributes are normalised - see\r\n * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria} for full details.\r\n *\r\n * @memberof external:jQuery\r\n * @instance\r\n * @alias    ariaState\r\n * @param    {Object|String} property\r\n *           Either a key/value combination properties to set or the name of the\r\n *           WAI-ARIA state to set.\r\n * @param    {Attribute_Callback|Boolean|Number|String} [value]\r\n *           Value of the attribute.\r\n * @return   {ARIA_state|jQuery}\r\n *           Either the jQuery object representing the modified elements\r\n *           (setting) or the state of the first matching element.\r\n *\r\n * @example <caption>Getting state</caption>\r\n * // Markup is:\r\n * // <div id=\"one\" aria-busy=\"true\" aria-checked=\"mixed\"></div>\r\n *\r\n * $(\"#one\").ariaState(\"busy\");    // -> true\r\n * $(\"#one\").ariaState(\"checked\"); // -> \"mixed\"\r\n * $(\"#one\").ariaState(\"hidden\");  // -> undefined\r\n *\r\n * @example <caption>Setting state</caption>\r\n * // Each of these will set the state to false:\r\n * $(\"#one\").ariaState(\"busy\", \"false\");\r\n * $(\"#one\").ariaState(\"busy\", \"FALSE\");\r\n * $(\"#one\").ariaState(\"busy\", false);\r\n * $(\"#one\").ariaState(\"busy\", 0);\r\n * $(\"#one\").ariaState(\"busy\", \"0\");\r\n *\r\n * // Each of these will set the state to \"mixed\":\r\n * $(\"#one\").ariaState(\"checked\", \"mixed\");\r\n * $(\"#one\").ariaState(\"checked\", \"MIXED\");\r\n *\r\n * // Each of these will set the state to true\r\n * $(\"#one\").ariaState(\"busy\", \"true\");\r\n * $(\"#one\").ariaState(\"busy\", \"TRUE\");\r\n * $(\"#one\").ariaState(\"busy\", true);\r\n * $(\"#one\").ariaState(\"busy\", 1);\r\n * $(\"#one\").ariaState(\"busy\", \"1\");\r\n * // WARNING: these also set the state to true\r\n * $(\"#one\").ariaState(\"busy\", {});\r\n * $(\"#one\").ariaState(\"busy\", null);\r\n * $(\"#one\").ariaState(\"busy\", \"nothing\");\r\n * $(\"#one\").ariaState(\"busy\", \"\");\r\n * $(\"#one\").ariaState(\"busy\", -1);\r\n *\r\n * // Each example returns a jQuery object representing \"#one\" and an object\r\n * // can be passed as parameters as well:\r\n * $(\"#one\").ariaState({\r\n *     busy: true\r\n * });\r\n *\r\n * @example <caption>Setting state with a function</caption>\r\n * // Markup is:\r\n * // <div class=\"checkbox\"></div>\r\n * // <input type=\"checkbox\" checked>\r\n *\r\n * $(\".checkbox\").ariaState(\"checked\", function (i, attr) {\r\n *\r\n *     return $(this)\r\n *         .next(\"input[type=\\\"checkbox\\\"]\")\r\n *         .prop(\"checked\");\r\n *\r\n * });\r\n *\r\n * // Now markup is:\r\n * // <div class=\"checkbox\" aria-checked=\"true\"></div>\r\n * // <input type=\"checkbox\" checked>\r\n */\r\n$.fn.ariaState = function (property, value) {\r\n\r\n    return access(\r\n        this,\r\n        property,\r\n        value,\r\n        HANDLER_STATE\r\n    );\r\n\r\n};\r\n\r\n// Source: \\src\\instance\\removeAria.js\n\r\n\r\n$.fn.extend({\r\n\r\n    removeAria: removeAttribute,\r\n\r\n    /**\r\n     * Alias of [jQuery#removeAria]{@link external:jQuery#removeAria}.\r\n     *\r\n     * @memberof external:jQuery\r\n     * @instance\r\n     * @function\r\n     * @param    {String} name\r\n     *           WAI-ARIA attribute to remove.\r\n     * @return   {jQuery}\r\n     *           jQuery attribute representing the elements modified.\r\n     */\r\n    removeAriaRef: removeAttribute,\r\n\r\n    /**\r\n     * Alias of [jQuery#removeAria]{@link external:jQuery#removeAria}.\r\n     *\r\n     * @memberof external:jQuery\r\n     * @instance\r\n     * @function\r\n     * @param    {String} name\r\n     *           WAI-ARIA attribute to remove.\r\n     * @return   {jQuery}\r\n     *           jQuery attribute representing the elements modified.\r\n     */\r\n    removeAriaState: removeAttribute\r\n\r\n});\r\n\r\n// Source: \\src\\instance\\role.js\n\r\n\r\n\r\n/**\r\n * Sets the role of all elements in the collection or gets the role of the first\r\n * element in the collection, depending on whether or not the <code>role</code>\r\n * argument is provided. As [jQuery#role]{@link external:jQuery#role} is just a\r\n * wrapper for [jQuery#attr]{@link http://api.jquery.com/attr/}, the\r\n * <code>role</code> parameter can actually be any value type that the official\r\n * documentation mentions.\r\n * <br><br>\r\n * According to the WAI-ARIA specs, an element can have mutliple roles as a\r\n * space-separated list. This method will only set the role attribute to the\r\n * given string when setting. If you want to modify the roles, use\r\n * [jQuery#addRole]{@link external:jQuery#addRole} and\r\n * [jQuery#removeRole]{@link external:jQuery#removeRole}.\r\n *\r\n * @memberof external:jQuery\r\n * @instance\r\n * @alias    role\r\n * @param    {Attribute_Callback|String} [role]\r\n *           Role to get or function to set the role.\r\n * @return   {jQuery|String|undefined}\r\n *           Either the jQuery object representing the elements that were\r\n *           modified or the role value.\r\n *\r\n * @example\r\n * // Markup is:\r\n * // <div id=\"one\"></div>\r\n * // <div id=\"two\"></div>\r\n *\r\n * $(\"#one\").role(\"presentation\"); // -> jQuery(<div id=\"one\">)\r\n *\r\n * // Now markup is:\r\n * // <div id=\"one\" role=\"presentation\"></div>\r\n * // <div id=\"two\"></div>\r\n *\r\n * $(\"#one\").role(); // -> \"presentation\"\r\n * $(\"#two\").role(); // -> undefined\r\n *\r\n * @example <caption>Setting a role with a function</caption>\r\n * // Markup is:\r\n * // <div id=\"one\" role=\"button\"></div>\r\n *\r\n * $(\"#one\").role(function (index, current) {\r\n *     return current + \" tooltip\";\r\n * });\r\n *\r\n * // Now markup is:\r\n * // <div id=\"one\" role=\"button tooltip\"></div>\r\n */\r\n$.fn.role = function (role) {\r\n\r\n    return role === undefined\r\n        ? this.attr(\"role\")\r\n        : this.attr(\"role\", role);\r\n\r\n};\r\n\r\n// Source: \\src\\instance\\addRole.js\n\r\n\r\n\r\n/**\r\n * Adds a role to a collection of elements. The role will not be added if it's\r\n * empty (\"\" or undefined), if the function response is empty or if the element\r\n * already has that role. In that way it's similar to\r\n * [jQuery#addClass]{@link https://api.jquery.com/addClass/}.\r\n *\r\n * @memberof external:jQuery\r\n * @instance\r\n * @alias    addRole\r\n * @param    {Attribute_Callback|String} role\r\n *           Role(s) to add to the matching elements or function to generate the\r\n *           role(s) to add.\r\n * @return   {jQuery}\r\n *           jQuery object representing the matching elements.\r\n *\r\n * @example <caption>Adding a role</caption>\r\n * // Markup is:\r\n * // <div class=\"one\" role=\"presentation\"></div>\r\n * // <div class=\"one\"></div>\r\n *\r\n * $(\".one\").addRole(\"alert\"); // -> jQuery(<div>, <div>)\r\n *\r\n * // Now markup is:\r\n * // <div class=\"one\" role=\"presentation alert\"></div>\r\n * // <div class=\"one\" role=\"alert\"></div>\r\n *\r\n * @example <caption>Adding a role with a function</caption>\r\n * // Markup is:\r\n * // <div class=\"one\" role=\"presentation\"></div>\r\n *\r\n * $(\".one\").addRole(function (index, current) {\r\n *     return \"alert combobox\";\r\n * });\r\n *\r\n * // Now markup is:\r\n * // <div class=\"one\" role=\"presentation alert combobox\"></div>\r\n */\r\n$.fn.addRole = function (role) {\r\n\r\n    var isFunction = $.isFunction(role);\r\n\r\n    return this.role(function (index, current) {\r\n\r\n        var value = isFunction\r\n            ? role.call(this, index, current)\r\n            : role;\r\n        var roles = toWords(current);\r\n\r\n        toWords(value).forEach(function (val) {\r\n\r\n            if (\r\n                val !== \"\"\r\n                && val !== undefined\r\n                && roles.indexOf(val) < 0\r\n            ) {\r\n                roles.push(val);\r\n            }\r\n\r\n        });\r\n\r\n        return roles.join(\" \");\r\n\r\n    });\r\n\r\n};\r\n\r\n// Source: \\src\\instance\\removeRole.js\n\r\n\r\n\r\n/**\r\n * Removes roles from the collection of elements. If the method is called\r\n * without any arguments then the role attribute itself is removed. Be aware\r\n * that this is not the same as passing a function which returns undefined -\r\n * such an action will have no effect.\r\n *\r\n * @memberof external:jQuery\r\n * @instance\r\n * @alias    removeRole\r\n * @param    {Attribute_Callback|String} [role]\r\n *           Role(s) to remove or a function to generate the role(s) to remove.\r\n * @return   {jQuery}\r\n *           jQuery object representing the matched elements.\r\n *\r\n * @example <caption>Removing a role</caption>\r\n * // Markup is:\r\n * // <div class=\"one\" role=\"presentation alert\"></div>\r\n * // <div class=\"one\" role=\"alert\"></div>\r\n *\r\n * $(\".one\").removeRole(\"alert\"); // -> jQuery(<div>, <div>)\r\n *\r\n * // Now markup is:\r\n * // <div class=\"one\" role=\"presentation\"></div>\r\n * // <div class=\"one\" role=\"\"></div>\r\n *\r\n * @example <caption>Completely removing a role</caption>\r\n * // Markup is:\r\n * // <div class=\"one\" role=\"presentation alert\"></div>\r\n * // <div class=\"one\" role=\"alert\"></div>\r\n *\r\n * $(\".one\").removeRole(); // -> jQuery(<div>, <div>)\r\n *\r\n * // Now markup is:\r\n * // <div class=\"one\"></div>\r\n * // <div class=\"one\"></div>\r\n *\r\n * @example <caption>Removing a role with a function</caption>\r\n * // Markup is:\r\n * // <div class=\"one\" role=\"presentation alert combobox\"></div>\r\n *\r\n * $(\".one\").removeRole(function (index, current) {\r\n *     return current\r\n *         .split(/\\s+/)\r\n *         .filter(function (role) {\r\n *             return role.indexOf(\"a\") > -1;\r\n *         })\r\n *         .join(\" \");\r\n *     // \"presentation alert\"\r\n * });\r\n *\r\n * // Now markup is:\r\n * // <div class=\"one\" role=\"combobox\"></div>\r\n */\r\n$.fn.removeRole = function (role) {\r\n\r\n    var isFunction = $.isFunction(role);\r\n\r\n    return role === undefined\r\n        ? this.removeAttr(\"role\")\r\n        : this.role(function (index, current) {\r\n\r\n            var value = isFunction\r\n                ? role.call(this, index, current)\r\n                : role;\r\n            var values = toWords(value);\r\n\r\n            return toWords(current)\r\n                .filter(function (aRole) {\r\n                    return values.indexOf(aRole) < 0;\r\n                })\r\n                .join(\" \");\r\n\r\n        });\r\n\r\n};\r\n\r\n// Source: \\src\\instance\\ariaFocusable.js\n\r\n\r\n\r\n/**\r\n * Sets whether or not the matching elements are focusable. Strings, numbers and\r\n * booleans are understood as <code>state</code> - see\r\n * [jQuery#ariaState]{@link external:jQuery#ariaState} for full details as the\r\n * algorythm is the same.\r\n * <br><br>\r\n * Be aware this this function will only modify the matching elements, it will\r\n * not check any parents or modify any other elements that could affect the\r\n * focusability of the element.\r\n *\r\n * @memberof external:jQuery\r\n * @instance\r\n * @alias    ariaFocusable\r\n * @param    {Attribute_Callback|Boolean|Number|String} state\r\n *           State to set.\r\n * @return   {jQuery}\r\n *           jQuery object representing the affected element(s).\r\n *\r\n * @example <caption>Setting focusability</caption>\r\n * // Markup is\r\n * // <div id=\"one\"></div>\r\n * // <div id=\"two\"></div>\r\n *\r\n * $(\"#one\").ariaFocusable(false); // -> jQuery(<div id=\"one\">)\r\n * $(\"#two\").ariaFocusable(true);  // -> jQuery(<div id=\"two\">)\r\n *\r\n * // Now markup is\r\n * // <div id=\"one\" tabindex=\"0\"></div>\r\n * // <div id=\"two\" tabindex=\"-1\"></div>\r\n *\r\n * @example <caption>Limitations of the function</caption>\r\n * // Markup is\r\n * // <div id=\"one\" tabindex=\"-1\">\r\n * //     <div id=\"two\" disabled></div>\r\n * // </div>\r\n *\r\n * $(\"#two\").ariaFocusable(true); // -> jQuery(<div id=\"two\">)\r\n *\r\n * // Now markup is\r\n * // <div id=\"one\" tabindex=\"-1\">\r\n * //     <div id=\"two\" disabled tabindex=\"0\"></div>\r\n * // </div>\r\n */\r\n$.fn.ariaFocusable = function (state) {\r\n\r\n    return this.attr(\r\n        \"tabindex\",\r\n        handlers[HANDLER_STATE].read(state)\r\n            ? 0\r\n            : -1\r\n    );\r\n\r\n};\r\n\n}(jQuery));"]}
